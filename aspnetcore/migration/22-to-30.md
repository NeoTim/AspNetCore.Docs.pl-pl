---
title: Migruj z ASP.NET Core 2,2 do 3,0
author: rick-anderson
description: Dowiedz się, jak migrować projekt ASP.NET Core 2,2 do ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 09/16/2019
uid: migration/22-to-30
ms.openlocfilehash: b1cce90f587265bfba67dcee6a7a45bb3a01f8ec
ms.sourcegitcommit: 79eeb17604b536e8f34641d1e6b697fb9a2ee21f
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/24/2019
ms.locfileid: "71211675"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migruj z ASP.NET Core 2,2 do 3,0

Przez [Scott Addie](https://github.com/scottaddie) i [Rick Anderson](https://twitter.com/RickAndMSFT)

W tym artykule wyjaśniono, jak zaktualizować istniejący projekt ASP.NET Core 2,2 do ASP.NET Core 3,0.

## <a name="prerequisites"></a>Wymagania wstępne

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio dla komputerów Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Zaktualizuj plik projektu

### <a name="update-the-target-framework"></a>Aktualizowanie platformy docelowej

Platforma ASP.NET Core 3.0 i nowsze wersje będą działać tylko na platformie .NET Core. Ustaw [moniker platformy docelowej (TFM)](/dotnet/standard/frameworks) na `netcoreapp3.0`:

```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
```

### <a name="remove-obsolete-package-references"></a>Usuń przestarzałe odwołania do pakietu

ASP.NET Core nie produkuje już dużej liczby funkcji pakietów NuGet. Te odwołania do pakietów powinny zostać usunięte z pliku projektu. Aby zapoznać się z pełną listą pakietów, które nie są już generowane, zobacz poniżej:

<details>
    <summary>Kliknij tutaj, aby rozwinąć listę pakietów, które nie są już generowane</summary>

    * Microsoft.AspNetCore
    * Microsoft.AspNetCore.All
    * Microsoft.AspNetCore.App
    * Microsoft. AspNetCore. przed fałszerstwem
    * Microsoft. AspNetCore. Authentication
    * Microsoft. AspNetCore. Authentication. Abstracts
    * Microsoft. AspNetCore. Authentication. cookies
    * Microsoft. AspNetCore. Authentication. Core
    * Microsoft. AspNetCore. Authentication. JwtBearer
    * Microsoft. AspNetCore. Authentication. OAuth
    * Microsoft. AspNetCore. Authentication. OpenIdConnect
    * Microsoft. AspNetCore. Authorization
    * Microsoft. AspNetCore. Authorization. Policy
    * Microsoft. AspNetCore. CookiePolicy
    * Microsoft. AspNetCore. CORS
    * Microsoft. AspNetCore. Cryptography. Internal
    * Microsoft. AspNetCore. Cryptography. datapochodny
    * Microsoft.AspNetCore.DataProtection
    * Microsoft. AspNetCore. dataprotection. Abstracts
    * Microsoft. AspNetCore. dataprotection. Extensions
    * Microsoft. AspNetCore. Diagnostics
    * Microsoft. AspNetCore. Diagnostics. HealthChecks
    * Microsoft.AspNetCore.HostFiltering
    * Microsoft.AspNetCore.Hosting
    * Microsoft. AspNetCore. hosting. Abstracts
    * Microsoft. AspNetCore. hosting. Server. Abstracts
    * Microsoft. AspNetCore. http
    * Microsoft. AspNetCore. http. Abstracts
    * Microsoft. AspNetCore. http. Connections
    * Microsoft. AspNetCore. http. Extensions
    * Microsoft. AspNetCore. http. Features
    * Microsoft. AspNetCore. HttpOverrides
    * Microsoft. AspNetCore. HttpsPolicy
    * Microsoft. AspNetCore. Identity
    * Microsoft. AspNetCore. Lokalizacja
    * Microsoft. AspNetCore. lokalizacja. Routing
    * Microsoft. AspNetCore. MiddlewareAnalysis
    * Microsoft.AspNetCore.Mvc
    * Microsoft. AspNetCore. MVC. Abstracts
    * Microsoft. AspNetCore. MVC. analizatory
    * Microsoft. AspNetCore. MVC. ApiExplorer
    * Microsoft. AspNetCore. MVC. API. analizatory
    * Microsoft. AspNetCore. MVC. Core
    * Microsoft. AspNetCore. MVC. CORS
    * Microsoft. AspNetCore. MVC. DataAnnotations
    * Microsoft. AspNetCore. MVC. Formatującegos. JSON
    * Microsoft. AspNetCore. MVC. Formatującegos. XML
    * Microsoft. AspNetCore. MVC. Lokalizacja
    * Microsoft.AspNetCore.Mvc.Razor
    * Microsoft. AspNetCore. MVC. Razor. Extensions
    * Microsoft. AspNetCore. MVC. Razor. ViewCompilation
    * Microsoft. AspNetCore. MVC. RazorPages
    * Microsoft. AspNetCore. MVC. TagHelpers
    * Microsoft. AspNetCore. MVC. ViewFeatures
    * Microsoft. AspNetCore. Razor
    * Microsoft. AspNetCore. Razor. Runtime
    * Microsoft. AspNetCore. Razor. Design
    * Microsoft. AspNetCore. ResponseCaching
    * Microsoft. AspNetCore. ResponseCaching. Abstracts
    * Microsoft. AspNetCore. ResponseCompression
    * Microsoft. AspNetCore. Write
    * Microsoft.AspNetCore.Routing
    * Microsoft. AspNetCore. Routing. Abstracts
    * Microsoft. AspNetCore. Server. HttpSys
    * Microsoft. AspNetCore. Server. IIS
    * Microsoft. AspNetCore. Server. IISIntegration
    * Microsoft. AspNetCore. Server. Kestrel
    * Microsoft. AspNetCore. Server. Kestrel. Core
    * Microsoft. AspNetCore. Server. Kestrel. https
    * Microsoft. AspNetCore. Server. Kestrel. transport. Abstracts
    * Microsoft. AspNetCore. Server. Kestrel. transport. Sockets
    * Microsoft. AspNetCore. Session
    * Microsoft. AspNetCore. sygnalizujący
    * Microsoft. AspNetCore. Signaler. Core
    * Microsoft.AspNetCore.StaticFiles
    * Microsoft. AspNetCore. WebSockets
    * Microsoft. AspNetCore. webutilities
    * Microsoft.Net. http. Headers</details>

### <a name="framework-reference"></a>Dokumentacja struktury

Funkcje ASP.NET Core, które były dostępne za pomocą jednego z wymienionych powyżej pakietów, są dostępne w `Microsoft.AspNetCore.App` ramach udostępnionej struktury.  *Platforma udostępniona* to zestaw zestawów (plików*dll* ), które są zainstalowane na komputerze i zawiera składnik środowiska uruchomieniowego oraz pakiet docelowy. Aby uzyskać więcej informacji, zobacz [udostępnioną strukturę](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).


* Projekty przeznaczone dla `Microsoft.NET.Sdk.Web` zestawu SDK niejawnie odwołują się do `Microsoft.AspNetCore.App` struktury.

Dla tych projektów nie są wymagane żadne dodatkowe odwołania:

```xml
<Project SDK="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>
    ...
</Project>
```

* Projekty przeznaczone dla `Microsoft.NET.Sdk` obiektów `Microsoft.NET.Sdk.Razor` docelowych lub SDK powinny dodawać jawne `FrameworkReference` do `Microsoft.AspNetCore.App`:

```xml
<Project SDK="Microsoft.NET.Sdk.Razor">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>
    ...
</Project>
```

### <a name="add-package-references-for-removed-assemblies"></a>Dodaj odwołania do pakietu dla usuniętych zestawów

ASP.NET Core 3,0 usuwa niektóre zestawy, które były wcześniej częścią `Microsoft.AspNetCore.App` odwołania do pakietu. Aby nadal korzystać z funkcji dostarczonych przez te zestawy, należy odwołać się do 3,0 wersji odpowiednich pakietów:

* Entity Framework Core — zobacz https://docs.microsoft.com/ef/core/providers/index , aby uzyskać więcej informacji na temat odwoływania się do pakietu specyficznego dla dostawcy bazy danych.

* Obsługę interfejsu użytkownika tożsamości dla [interfejsu użytkownika tożsamości](xref:security/authentication/identity) można dodać, odwołując się do pakietu [Microsoft. AspNetCore. Identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* SPA usługi
    * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
    * [Microsoft. AspNetCore. SpaServices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Uwierzytelnianie — obsługa przepływów uwierzytelniania innych firm jest dostępna jako pakiety NuGet:

    * [Uwierzytelnianie OAuth w serwisie Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook)
    * [Google OAuth](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google)
    * [Token okaziciela OpenID Connect Connect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer)
    * [Uwierzytelnianie konta Microsoft](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount)
    * [Uwierzytelnianie przy OpenID Connect Connect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect)
    * [Protokół OAuth usługi Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter)
    * [Uwierzytelnianie WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation)

* Obsługa formatowania i negocjacji zawartości dla `System.Net.HttpClient` — pakiet NuGet [Microsoft. ASPNET. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) `System.Net.HttpClient` oferuje przydatną rozszerzalność z użyciem interfejsów API `ReadAsAsync`, `PostJsonAsync` takich jak itd.

* Kompilacja środowiska uruchomieniowego Razor — obsługa kompilowania widoków i stron środowiska uruchomieniowego w czasie wykonywania jest teraz częścią [Microsoft. AspNetCore. MVC. Razor. RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* Obsługa `Newtonsoft.Json` MVC — obsługa używania MVC with `Newtonsoft.Json` jest teraz częścią [Microsoft. AspNetCore. MVC. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

### <a name="analyzer-support"></a>Obsługa analizatora

* Projekty, które `Microsoft.NET.Sdk.Web` są przeznaczone dla niejawnie przywoływanych analizatorów odwołań, które zostały wcześniej wysłane jako część pakietu [Microsoft. AspNetCore. MVC. analizatory](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . Nie są wymagane żadne dodatkowe odwołania, aby je włączyć.

* Jeśli aplikacja używa [analizatorów interfejsów API](xref:web-api/advanced/analyzers) wcześniej dostarczonych przy użyciu pakietu [Microsoft. AspNetCore. MVC. API. analizatory](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , edytuj plik projektu, aby odwoływać się do analizatorów dostarczonych w ramach zestawu SDK sieci Web platformy .NET Core:

```xml
<Project SDK="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
    <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
  </PropertyGroup>

  ...
</Project>
```

### <a name="razor-class-library"></a>Biblioteka klas Razor

Projekty biblioteki klas Razor, które zapewniają składniki interfejsu użytkownika dla MVC, `AddRazorSupportForMvc` muszą ustawiać właściwość w pliku projektu:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Model hostingu w procesie

* Projekty są domyślne dla [modelu hostingu w procesie](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) w ASP.NET Core 3,0 lub nowszym. Opcjonalnie można usunąć `<AspNetCoreHostingModel>` właściwość w pliku projektu, jeśli jej wartość jest `InProcess`.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Konfiguracja

Migruj konfigurację Kestrel do konstruktora hosta sieci Web dostarczonego `ConfigureWebHostDefaults` przez program (*program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Jeśli aplikacja tworzy hosta ręcznie przy użyciu `HostBuilder`programu, należy wywołać `UseKestrel` konstruktora hosta sieci Web w `ConfigureWebHostDefaults`:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Oprogramowanie pośredniczące połączenia zastępuje karty połączeń

Adaptery połączeń<xref:Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter>() zostały usunięte z Kestrel. Zamień karty połączeń na oprogramowanie pośredniczące połączenia. Oprogramowanie pośredniczące połączenia jest podobne do oprogramowania pośredniczącego HTTP w potoku ASP.NET Core, ale dla połączeń niższego poziomu. Rejestrowanie protokołu HTTPS i połączeń:

* Zostały przeniesione z kart połączeń do oprogramowania pośredniczącego połączenia.
* Te metody rozszerzające działają tak jak w poprzednich wersjach ASP.NET Core. 

Aby uzyskać więcej informacji, zobacz [przykład TlsFilterConnectionHandler w sekcji ListenOptions. Protocols artykułu Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Abstrakcje transportu przenoszone i udostępniane publicznie

Warstwa transportu Kestrel została udostępniona jako interfejs publiczny w programie `Connections.Abstractions`. W ramach tych aktualizacji:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`i skojarzone typy zostały usunięte.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>został przeniesiony z <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> do opcji transportu.
* <xref:Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode>został usunięty z <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>.

Aby uzyskać więcej informacji, zobacz następujące zasoby w witrynie GitHub:

* [Abstrakcje sieci klienta/serwera (ASPNET/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Zaimplementuj nowe abstrakcję odbiornika nimi i ponowne umieszczanie Kestrel na wierzchu (ASPNET/AspNetCore #10321)](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Nagłówki naczepy żądania Kestrel

Dla aplikacji przeznaczonych dla wcześniejszych wersji ASP.NET Core:

* Kestrel dodaje nagłówki przegałęzień protokołu HTTP/1.1 do kolekcji nagłówków żądań.
* Przyczepy są dostępne po odczytaniu treści żądania na końcu.

Powoduje to pewne wątpliwości dotyczące niejednoznaczności między nagłówkami i przyczepami, dlatego przyczepy zostały przeniesione do nowej kolekcji (`RequestTrailerExtensions`) w 3,0.

Żądania protokołu HTTP/2 są następujące:

* Niedostępne w ASP.NET Core 2,2.
* Dostępne w 3,0 jako `RequestTrailerExtensions`.

Nowe metody rozszerzenia żądania są obecne w celu uzyskania dostępu do tych przyczep. Podobnie jak w przypadku protokołu HTTP/1.1, przyczepy są dostępne po odczytaniu treści żądania na końcu.

W przypadku wersji 3,0 dostępne są następujące `RequestTrailerExtensions` metody:

* `GetDeclaredTrailers`Pobiera nagłówek żądania `Trailer` , który zawiera listę przyczep, które mają być oczekiwane po treści. &ndash;
* `SupportsTrailers`&ndash; Wskazuje, czy żądanie obsługuje nagłówki przyczepy.
* `CheckTrailersAvailable`&ndash; Sprawdza, czy żądanie obsługuje przyczepy i czy są dostępne do odczytu. To sprawdzenie nie zakłada, że istnieją przyczepy do odczytu. Być może nie ma żadnych przyczep do odczytania `true` , nawet jeśli jest zwracany przez tę metodę.
* `GetTrailer`&ndash; Pobiera żądany końcowy nagłówek z odpowiedzi. Sprawdź `SupportsTrailers` przed wywołaniem `GetTrailer`lub <xref:System.NotSupportedException> może wystąpić, jeśli żądanie nie obsługuje końcowych nagłówków.

Aby uzyskać więcej informacji, zobacz [Umieszczanie przyczep żądań w oddzielnej kolekcji (ASPNET/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO wyłączone

`AllowSynchronousIO`Włącza lub wyłącza synchroniczne interfejsy API we/wy `HttpRequest.Body.Read`, `HttpResponse.Body.Write`takie jak `Stream.Flush`, i. Te interfejsy API są źródłem zablokowania wątków prowadzącego do awarii aplikacji. W 3,0, `AllowSynchronousIO` jest domyślnie wyłączona. Aby uzyskać więcej informacji, zobacz [sekcję synchronicznej operacji we/wy w artykule Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Oprócz opcji włączania `AllowSynchronousIO` z `ConfigureKestrel`użyciem synchroniczne operacje we/wy mogą być również zastępowane na podstawie żądania jako tymczasowe środki zaradcze:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Jeśli masz problemy z <xref:System.IO.TextWriter> implementacjami lub innymi strumieniami wywołującymi synchroniczne interfejsy API w operacji [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), <xref:System.IO.Stream.DisposeAsync*> zamiast tego wywołaj nowy interfejs API.

Aby uzyskać więcej informacji, zobacz [[anons] AllowSynchronousIO wyłączone na wszystkich serwerach (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Zestaw Microsoft. AspNetCore. Server. Kestrel. https został usunięty

W ASP.NET Core 2,1 zawartość *Microsoft. AspNetCore. Server. Kestrel. https. dll* została przeniesiona do pliku *Microsoft. AspNetCore. Server. Kestrel. Core. dll*. To była nieprzerwana Aktualizacja przy użyciu `TypeForwardedTo` atrybutów. W przypadku 3,0 pusty zestaw *Microsoft. AspNetCore. Server. Kestrel. https. dll* (i pakiet NuGet) został usunięty.

Biblioteki odwołujące się do [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) powinny aktualizować ASP.NET Core zależności do 2,1 lub nowszych.

Aplikacje i biblioteki ukierunkowane na ASP.NET Core 2,1 lub nowsze powinny usunąć wszystkie bezpośrednie odwołania do pakietu [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

## <a name="jsonnet-support"></a>Obsługa Json.NET

W ramach pracy w celu [usprawnienia ASP.NET Core udostępnionej struktury](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/) [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) został usunięty z ASP.NET Core udostępnionej platformy.

Wartość domyślna dla ASP.NET Core to teraz [System. Text. JSON](/dotnet/api/system.text.json?view=netcore-3.0), który jest nowy w programie .net Core 3,0. Rozważ użycie `System.Text.Json` , gdy jest to możliwe. Jest wysoka wydajność i nie wymaga dodatkowej zależności biblioteki. Jednak od momentu `System.Text.Json` , gdy jest to nowe, może to oznaczać brak funkcji wymaganych przez aplikację.

Aplikacja może `Netwtonsoft.Json` wymagać integracji, jeśli `Newtonsoft.Json`używa funkcji specyficznej, takiej jak JsonPatch lub Converters, lub jeśli [formatuje](xref:web-api/advanced/formatting) `Newtonsoft.Json`typy specyficzne dla tego programu.

Aby użyć Json.NET w projekcie ASP.NET Core sygnalizującego 3,0, zobacz [Switch to Newtonsoft. JSON](#switch-to-newtonsoftjson) w tym dokumencie.

Aby użyć Json.NET w projekcie ASP.NET Core 3,0:

* Dodaj odwołanie do pakietu do [Microsoft. AspNetCore. MVC. NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Aktualizacja `Startup.ConfigureServices` do wywołania `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`jest zgodny z nowymi metodami rejestracji usługi MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Ustawienia Json.NET można ustawić w wywołaniu `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Rejestracja usługi MVC

ASP.NET Core 3,0 dodaje nowe opcje rejestrowania scenariuszy MVC wewnątrz `Startup.ConfigureServices`.

Dostępne `IServiceCollection` są trzy nowe metody rozszerzenia najwyższego poziomu związane z scenariuszami MVC. Szablony wykorzystują te nowe metody zamiast `UseMvc`. Jednak nadal `AddMvc` zachowuje się tak, jak w poprzednich wersjach.

Poniższy przykład dodaje obsługę kontrolerów i funkcji związanych z interfejsem API, ale nie widoków ani stron. Szablon interfejsu API używa tego kodu:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Poniższy przykład dodaje obsługę kontrolerów, funkcji związanych z interfejsem API i widoków, ale nie stron. Szablon aplikacji sieci Web (MVC) używa tego kodu:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Poniższy przykład dodaje obsługę Razor Pages i minimalną obsługę kontrolera. Szablon aplikacji sieci Web używa tego kodu:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Nowe metody można również łączyć. Poniższy przykład jest odpowiednikiem wywołania `AddMvc` w ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Kod uruchomienia routingu

Jeśli aplikacja wywołuje `UseMvc` lub `UseSignalR`migruje aplikację do [routingu punktów końcowych](xref:fundamentals/routing) , jeśli jest to możliwe. Aby zwiększyć zgodność routingu punktów końcowych z poprzednimi wersjami MVC, zostały przywrócone niektóre zmiany w generowaniu adresów URL wprowadzone w ASP.NET Core 2,2. Jeśli wystąpią problemy z użyciem routingu punktów końcowych w 2,2, należy oczekiwać ulepszeń w ASP.NET Core 3,0 z następującymi wyjątkami:

* Jeśli aplikacja implementuje `IRouter` lub dziedziczy po `Route`, należy użyć [DynamicRouteValuesTransformer](https://github.com/aspnet/AspNetCore.Docs/issues/12997) jako zamiennika.

* Jeśli aplikacja bezpośrednio uzyskuje dostęp `RouteData.Routers` do wewnątrz MVC do analizowania adresów URL, można ją zastąpić przy `LinkParser.ParsePathByEndpointName`użyciu. 
 * Zdefiniuj trasę przy użyciu nazwy trasy.
 * Użyj `LinkParser.ParsePathByEndpointName` i przekaż żądaną nazwę trasy.

Routing punktów końcowych obsługuje tę samą składnię wzorca trasy i funkcje `IRouter`tworzenia wzorców tras. Obsługa `IRouteConstraint`routingu punktów końcowych. Routing punktów końcowych `[HttpGet]`obsługuje `[Route]`, i inne atrybuty routingu MVC.

W przypadku większości aplikacji wymagane `Startup` są jedynie zmiany.

### <a name="migrate-startupconfigure"></a>Migrowanie uruchamiania. Skonfiguruj

Ogólne porady:

* Dodaj `UseRouting`.
* Jeśli aplikacja jest wywoływana `UseStaticFiles`, umieść `UseStaticFiles` **przed** `UseRouting`.
* Jeśli aplikacja korzysta z funkcji uwierzytelniania/autoryzacji, takich `AuthorizePage` jak `[Authorize]`lub, należy je umieścić `UseAuthentication` do `UseAuthorization` i **po** `UseRouting` . `UseCors`
* Zamień `UseMvc` lub `UseSignalR` na .`UseEndpoints`
* Jeśli aplikacja używa scenariuszy [CORS](xref:security/cors) , takich jak `[EnableCors]`, należy `UseCors` umieścić wywołanie przed dowolnym innym oprogramowanie pośredniczące, które używa mechanizmu CORS (na przykład Umieść `UseCors` przed `UseAuthentication`, `UseAuthorization`, i `UseEndpoints`).
* Zamień `IHostingEnvironment`na i`using` Dodaj instrukcję dla przestrzeninazw.<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> `IWebHostEnvironment`
* Zamień `IApplicationLifetime` na <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> przestrzeń nazw).
* Zamień `EnvironmentName` na <xref:Microsoft.Extensions.Hosting.Environments> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> przestrzeń nazw).

Poniższy kod jest przykładem `Startup.Configure` w typowej aplikacji ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Po zaktualizowaniu poprzedniego `Startup.Configure` kodu:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> W przypadku większości aplikacji wywołania `UseAuthentication`, `UseAuthorization`i `UseCors` muszą znajdować się między wywołaniami `UseRouting` i `UseEndpoints` , aby obowiązywać.
### <a name="health-checks"></a>Kontrole kondycji

Kontrole kondycji korzystają z routingu punktu końcowego z hostem ogólnym. W `Startup.Configure`programie Wywołaj `MapHealthChecks` program Endpoint Builder z adresem URL punktu końcowego lub ścieżką względną:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Punkty końcowe sprawdzania kondycji mogą:

* Określ jeden lub więcej dozwolonych hostów/portów.
* Wymagaj autoryzacji.
* Wymagaj mechanizmu CORS.

Aby uzyskać więcej informacji, zobacz <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Wskazówki dotyczące oprogramowania pośredniczącego zabezpieczeń

Obsługa autoryzacji i mechanizmu CORS jest ujednolicona dla podejścia [pośredniczącego](xref:fundamentals/middleware/index) . Pozwala to korzystać z tego samego oprogramowania pośredniczącego i funkcji w tych scenariuszach. Zaktualizowane oprogramowanie pośredniczące autoryzacji jest dostępne w tej wersji, a oprogramowanie do obsługi mechanizmu CORS jest ulepszone, aby można było zrozumieć atrybuty używane przez kontrolery MVC.

#### <a name="cors"></a>CORS

Wcześniej mechanizm CORS może być trudny do skonfigurowania. Oprogramowanie pośredniczące zostało dostarczone do użycia w niektórych przypadkach użycia, ale filtry MVC były przeznaczone do użycia **bez** oprogramowania pośredniczącego w innych przypadkach użycia. W ASP.NET Core 3,0 zalecamy, aby wszystkie aplikacje wymagające mechanizmu CORS korzystały z oprogramowania pośredniczącego CORS wspólnie z routingiem punktów końcowych. `UseCors`można podać przy użyciu domyślnych zasad i `[EnableCors]` `[DisableCors]` można użyć atrybutów, aby zastąpić zasady domyślne, gdy jest to wymagane.

W poniższym przykładzie:

* Funkcja CORS jest włączona dla wszystkich punktów końcowych z `default` nazwanymi zasadami.
* Klasa wyłącza funkcję CORS `[DisableCors]` z atrybutem. `MyController`

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autoryzacja

We wcześniejszych wersjach ASP.NET Core Obsługa autoryzacji była świadczona za pośrednictwem `[Authorize]` atrybutu. Oprogramowanie pośredniczące autoryzacji nie jest dostępne. W ASP.NET Core 3,0 wymagane jest oprogramowanie pośredniczące autoryzacji. `UseAuthorization` Zalecamy`UseAuthentication`natychmiastowe umieszczenie oprogramowania pośredniczącego autoryzacji ASP.NET Core (). Oprogramowanie pośredniczące autoryzacji można także skonfigurować przy użyciu zasad domyślnych, które mogą zostać zastąpione.

W ASP.NET Core 3,0 lub nowszej `UseAuthorization` jest wywoływana w `Startup.Configure`, a następujące elementy `HomeController` wymagają zalogowanego użytkownika:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Jeśli aplikacja używa `AuthorizeFilter` jako filtru globalnego w MVC, zalecamy refaktoryzację kodu w celu zapewnienia zasad w `AddAuthorization`wywołaniu.

`DefaultPolicy` Początkowo skonfigurowano wymaganie uwierzytelniania, dlatego nie jest wymagana żadna dodatkowa konfiguracja. W poniższym przykładzie punkty końcowe MVC są oznaczone jako `RequireAuthorization` tak, że wszystkie żądania muszą być autoryzowane na podstawie. `DefaultPolicy` Jednak zezwala na `HomeController` dostęp bez logowania użytkownika do aplikacji `[AllowAnonymous]`z powodu:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Zasady można także dostosować. Kompilowanie w poprzednim przykładzie `DefaultPolicy` jest skonfigurowane tak, aby wymagało uwierzytelniania i określonego zakresu:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Alternatywnie wszystkie punkty końcowe można skonfigurować tak, aby wymagały `[Authorize]` autoryzacji `RequireAuthorization` , bez konieczności `FallbackPolicy`konfigurowania. Różni `FallbackPolicy` się`DefaultPolicy`od. Jest wyzwalany przez `[Authorize]` lub `RequireAuthorization`, podczas `FallbackPolicy` gdy jest wyzwalane, gdy nie ustawiono żadnych innych zasad. `DefaultPolicy` `FallbackPolicy`jest początkowo skonfigurowana do zezwalania na żądania bez autoryzacji.

Poniższy przykład jest taki sam jak w poprzednim `DefaultPolicy` przykładzie, ale używa do zawsze Wymagaj uwierzytelniania we wszystkich punktach końcowych, z wyjątkiem sytuacji, `FallbackPolicy` gdy `[AllowAnonymous]` jest określony:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Autoryzacja przez oprogramowanie pośredniczące działa bez struktury, która ma konkretną wiedzę o autoryzacji. Na przykład [kontrole kondycji](xref:host-and-deploy/health-checks) nie mają określonej znajomości autoryzacji, ale kontrole kondycji mogą mieć konfigurowalne zasady autoryzacji stosowane przez oprogramowanie pośredniczące.

Ponadto każdy punkt końcowy może dostosować wymagania dotyczące autoryzacji. W `UseAuthorization` poniższym przykładzie program przetwarza autoryzację `DefaultPolicy`przy użyciu, ale `/healthz` punkt końcowy sprawdzania kondycji wymaga `admin` użytkownika:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Ochrona jest zaimplementowana w niektórych scenariuszach. `UseEndpoint`Oprogramowanie pośredniczące zgłasza wyjątek, jeśli zasady autoryzacji lub mechanizmu CORS zostały pominięte ze względu na brak oprogramowania pośredniczącego. Obsługa analizatora, aby zapewnić dodatkową opinię na temat niedziałania konfiguracji.

### <a name="signalr"></a>SignalR

Mapowanie centrów sygnałów teraz odbywa się wewnątrz `UseEndpoints`.

Mapuj każde centrum za `MapHub`pomocą. Tak jak w poprzednich wersjach, każde centrum jest jawnie wymienione.

W poniższym przykładzie dodano obsługę `ChatHub` centrum sygnałów:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Istnieje nowa opcja kontrolowania limitów rozmiaru komunikatów od klientów. Na przykład w `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

W ASP.NET Core 2,2 można ustawić `TransportMaxBufferSize` i, który efektywnie kontroluje maksymalny rozmiar komunikatu. W ASP.NET Core 3,0 ta opcja teraz kontroluje maksymalny rozmiar tylko przed zaobserwowaniem wartości.

### <a name="mvc-controllers"></a>Kontrolery MVC

Teraz trwa `UseEndpoints`mapowanie kontrolerów.

Dodaj `MapControllers` , jeśli aplikacja używa routingu atrybutów. Ponieważ Routing obejmuje obsługę wielu struktur w ASP.NET Core 3,0 lub nowszych, Dodawanie kontrolerów z obsługą atrybutu jest zgodą.

Zastąp następujące:

* `MapRoute`się`MapControllerRoute`
* `MapAreaRoute`się`MapAreaControllerRoute`

Ponieważ Routing obejmuje teraz obsługę więcej niż tylko MVC, terminologia zmieniła się w taki sposób, że te metody jasno określają to, co robią. Trasy konwencjonalne, takie `MapControllerRoute` jak / `MapAreaControllerRoute` sąstosowanewkolejności,wjakiejzostałydodane./ `MapDefaultControllerRoute` Najpierw umieść bardziej szczegółowe trasy (takie jak trasy dla obszaru).

W poniższym przykładzie:

* `MapControllers`dodaje obsługę kontrolerów z routingiem z atrybutami.
* `MapAreaControllerRoute`dodaje konwencjonalne trasy dla kontrolerów w obszarze.
* `MapControllerRoute`dodaje konwencjonalne trasy dla kontrolerów.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="razor-pages"></a>Razor Pages

Mapowanie Razor Pages teraz odbywa się wewnątrz `UseEndpoints`.

Dodaj `MapRazorPages` , jeśli aplikacja używa Razor Pages. Ponieważ Routing punktów końcowych obejmuje obsługę wielu struktur, dodanie Razor Pages jest teraz zgodą.

W poniższym przykładzie `MapRazorPages` dodano obsługę Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Korzystanie z MVC bez routingu punktu końcowego

Użycie MVC przez `UseMvc` lub `UseMvcWithDefaultRoute` w ASP.NET Core 3,0 wymaga jawnej zgody w wewnątrz `Startup.ConfigureServices`. Jest to wymagane, ponieważ MVC musi wiedzieć, czy może polegać na oprogramowaniu pośredniczącym i oprogramowaniu CORS podczas inicjacji. Zostanie dostarczony Analizator ostrzegający, czy aplikacja próbuje użyć nieobsługiwanej konfiguracji.

Jeśli aplikacja wymaga starszej `IRouter` obsługi, należy `EnableEndpointRouting` wyłączyć korzystanie z następujących metod w programie `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Kontrole kondycji

Kontrole kondycji mogą służyć jako oprogramowanie *do przesyłania i kierowania* punktów końcowych.

Dodawanie `MapHealthChecks` do korzystania z kontroli kondycji przy użyciu routingu punktu końcowego. Metoda akceptuje argumenty podobne do `UseHealthChecks`. `MapHealthChecks` Zaletą korzystania z `MapHealthChecks` tej `UseHealthChecks` funkcji jest możliwość zastosowania autoryzacji i zwiększenia szczegółowej kontroli nad pasującymi zasadami.

W poniższym przykładzie `MapHealthChecks` jest wywoływana dla punktu końcowego sprawdzania kondycji w `/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder zastępuje WebHostBuilder

Szablony ASP.NET Core 3,0 korzystają z [hosta ogólnego](xref:fundamentals/host/generic-host). Poprzednie wersje używają [hosta sieci Web](xref:fundamentals/host/web-host). Poniższy kod przedstawia klasę ASP.NET Core 3,0 wygenerowaną `Program` przez szablon:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Poniższy kod przedstawia klasę ASP.NET Core 2,2 wygenerowaną `Program` przez szablon:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>pozostanie w 3,0 i jest typem `webBuilder` widocznym w poprzednim przykładzie kodu. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>będzie przestarzałe w przyszłej wersji i zastąpione przez `HostBuilder`.

Najbardziej znacząca zmiana z `WebHostBuilder` do `HostBuilder` na jest [iniekcją zależności (di)](xref:fundamentals/dependency-injection). W przypadku `HostBuilder`korzystania z programu można <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> wstrzyknąć <xref:Microsoft.Extensions.Configuration.IConfiguration> `Startup`tylko konstruktora. Ograniczenia `HostBuilder` di:

* Zezwól na kompilowanie kontenera DI tylko raz.
* Pozwala uniknąć problemów z okresem istnienia obiektów, takich jak rozpoznawanie wielu wystąpień pojedynczych.

## <a name="addauthorization-moved-to-a-different-assembly"></a>Element addauthorization został przeniesiony do innego zestawu

ASP.NET Core 2,2 i niższe `AddAuthorization` metody w *pliku Microsoft. AspNetCore. Authorization. dll*:

* Zmieniono nazwę `AddAuthorizationCore`.
* Zostały przeniesione do *pliku Microsoft. AspNetCore. Authorization. Policy. dll*.

Nie ma to wpływu na aplikacje, które korzystają z plików *Microsoft. AspNetCore. Authorization. dll* i *Microsoft. AspNetCore. Authorization. Policy. dll* .

Aplikacje, które nie korzystają z *programu Microsoft. AspNetCore. Authorization. Policy. dll* , powinny wykonać jedną z następujących czynności:

* Przełącz do korzystania z`AddAuthorizationCore`
* Dodaj odwołanie do *pliku Microsoft. AspNetCore. Authorization. Policy. dll*.

Aby uzyskać więcej informacji, zobacz artykuł dotyczący [nadmiernej zmiany w programie `AddAuthorization(o =>`) w innym zestawie #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="signalr-code"></a>Kod sygnalizujący

Klient JavaScript sygnalizujący zmienił się z `@aspnet/signalr` na. `@microsoft/signalr` Aby reagować na tę zmianę, należy zmienić odwołania w plikach *Package. JSON* , instrukcjach Wymagaj i instrukcjach import języka ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON jest domyślnym protokołem

`System.Text.Json`jest teraz domyślnym protokołem centrum używanym przez klienta i serwer.

W `Startup.ConfigureServices`programie Wywołaj `AddJsonProtocol` polecenie, aby ustawić opcje serializatora.

**Server**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Klient:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Przejdź do pliku Newtonsoft. JSON

Jeśli używasz funkcji programu `Newtonsoft.Json` , które nie są obsługiwane w programie `System.Text.Json`, możesz przełączyć się z `Newtonsoft.Json`powrotem do:

1. Zainstaluj pakiet NuGet [Microsoft. AspNetCore. Signal. Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. Na kliencie należy utworzyć `AddNewtonsoftJsonProtocol` łańcuch wywołań metody `HubConnectionBuilder` do wystąpienia:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Na serwerze należy utworzyć `AddNewtonsoftJsonProtocol` łańcuch wywołania `AddSignalR` metody wywołania metody w `Startup.ConfigureServices`:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Zezwól na kompilację środowiska uruchomieniowego

W 3,0, Kompilacja środowiska uruchomieniowego jest scenariuszem wyboru. Aby włączyć kompilację środowiska uruchomieniowego, zobacz <xref:mvc/views/view-compilation#runtime-compilation>.

## <a name="migrating-libraries-via-multi-targeting"></a>Migrowanie bibliotek poprzez wiele elementów docelowych

Biblioteki często muszą obsługiwać wiele wersji ASP.NET Core. Większość bibliotek, które zostały skompilowane przed poprzednimi wersjami ASP.NET Core, powinna działać bez problemów. Następujące warunki wymagają, aby aplikacja była skompilowana:

* Biblioteka korzysta z funkcji, która ma istotną [zmianę](#breaking-api-changes)w postaci binarnej.
* Biblioteka chce korzystać z nowych funkcji w ASP.NET Core 3,0. 

Na przykład:

```xml
<Project SDK="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Użyj `#ifdefs` , aby lekkich interfejsów API ASP.NET Core 3,0:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#else if NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

## <a name="breaking-api-changes"></a>Przerywanie zmian interfejsu API

Aby uzyskać dodatkowe istotne zmiany w wersji ASP.NET Core 3,0, zobacz [repozytorium ASPNET/anonse](https://github.com/aspnet/Announcements/issues?page=2&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0). Aby uzyskać podsumowanie dotyczące podziału od 2,2 do 3,0 na platformie .NET Core, ASP.NET Core i Entity Framework Core, zobacz istotne [zmiany dotyczące migracji z wersji 2,2 do 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="aspnet-core-30-not-currently-available-for-azure-app-service"></a>ASP.NET Core 3,0 nie jest obecnie dostępna dla Azure App Service. 

Mamy nadzieję, że udostępnimy to wkrótce. Dopóki ASP.NET Core 3,0 jest dostępny w Azure App Service, postępuj zgodnie z instrukcjami podanymi w tematach [wdrażanie ASP.NET Core wersja zapoznawcza do Azure App Service](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).
