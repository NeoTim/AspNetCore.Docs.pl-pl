---
title: Migruj z ASP.NET Core 2,2 do 3,0
author: rick-anderson
description: Dowiedz się, jak migrować projekt ASP.NET Core 2,2 do ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 10/15/2019
uid: migration/22-to-30
ms.openlocfilehash: 7d7f5f8b1624e1186d1427852365b9a5ba7018ca
ms.sourcegitcommit: 07d98ada57f2a5f6d809d44bdad7a15013109549
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/15/2019
ms.locfileid: "72333776"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migruj z ASP.NET Core 2,2 do 3,0

Przez [Scott Addie](https://github.com/scottaddie) i [Rick Anderson](https://twitter.com/RickAndMSFT)

W tym artykule wyjaśniono, jak zaktualizować istniejący projekt ASP.NET Core 2,2 do ASP.NET Core 3,0.

## <a name="prerequisites"></a>Wymagania wstępne

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio dla komputerów Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Aktualizacja wersji zestaw .NET Core SDK w pliku Global. JSON

Jeśli Twoje rozwiązanie polega na pliku [Global. JSON](/dotnet/core/tools/global-json) , który będzie przeznaczony dla konkretnej wersji zestaw .NET Core SDK, zaktualizuj właściwość `version` do wersji 3,0 zainstalowanej na maszynie:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Zaktualizuj plik projektu

### <a name="update-the-target-framework"></a>Aktualizowanie platformy docelowej

ASP.NET Core 3,0 i nowsze są uruchamiane tylko na platformie .NET Core. Ustaw [moniker platformy docelowej (TFM)](/dotnet/standard/frameworks) na `netcoreapp3.0`:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Usuń przestarzałe odwołania do pakietu

ASP.NET Core nie produkuje już dużej liczby funkcji pakietów NuGet. Te odwołania do pakietów powinny zostać usunięte z pliku projektu. Na przykład plik projektu wygenerowany przez szablon dla aplikacji internetowej ASP.NET Core 2,2:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>


  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Zaktualizowany plik projektu ASP.NET Core 3,0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Zaktualizowany plik projektu ASP.NET Core 3,0:

* W `<PropertyGroup>`:

  * Aktualizuje TFM do `netcoreapp3.0`
  * Usuwa element `<AspNetCoreHostingModel>`. Aby uzyskać więcej informacji, zobacz [model hostingu w procesie](#in-process-hosting-model) w tym dokumencie.

* W `<ItemGroup>`:

  * `Microsoft.AspNetCore.App` jest usuwany. Aby uzyskać więcej informacji, zobacz temat [Informacje o strukturze](#framework-reference) w tym dokumencie.
  * `Microsoft.AspNetCore.Razor.Design` zostaje usunięty i na poniższej liście pakietów nie jest już generowany.

Aby wyświetlić pełną listę pakietów, które nie są już generowane, wybierz następującą listę rozwijaną:

<details>
    <summary>Kliknij tutaj, aby rozwinąć listę pakietów, które nie są już generowane</summary>
    <ul>
        <li>Microsoft. AspNetCore</li>
        <li>Microsoft. AspNetCore. All</li>
        <li>Microsoft. AspNetCore. App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.JwtBearer</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authentication.OpenIdConnect</li>
        <li>Microsoft.AspNetCore.Authorization</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Cryptography.Internal</li>
        <li>Microsoft.AspNetCore.Cryptography.KeyDerivation</li>
        <li>Microsoft. AspNetCore. dataprotection</li>
        <li>Microsoft.AspNetCore.DataProtection.Abstractions</li>
        <li>Microsoft.AspNetCore.DataProtection.Extensions</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft. AspNetCore. HostFiltering</li>
        <li>Microsoft. AspNetCore. hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.Http.Features</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.MiddlewareAnalysis</li>
        <li>Microsoft. AspNetCore. MVC</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft. AspNetCore. MVC. Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.Extensions</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft. AspNetCore. Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft.AspNetCore.SignalR</li>
        <li>Microsoft.AspNetCore.SignalR.Core</li>
        <li>Microsoft. AspNetCore. StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net. http. Headers</li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Przejrzyj istotne zmiany

[Przejrzyj istotne zmiany](#break)

### <a name="framework-reference"></a>Dokumentacja struktury

Funkcje ASP.NET Core, które były dostępne za pomocą jednego z wymienionych powyżej pakietów, są dostępne w ramach struktury udostępnionej `Microsoft.AspNetCore.App`. *Platforma udostępniona* to zestaw zestawów (plików*dll* ), które są zainstalowane na komputerze i zawiera składnik środowiska uruchomieniowego oraz pakiet docelowy. Aby uzyskać więcej informacji, zobacz [udostępnioną strukturę](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Projekty przeznaczone dla zestawu SDK `Microsoft.NET.Sdk.Web` niejawnie odwołują się do struktury `Microsoft.AspNetCore.App`.

Dla tych projektów nie są wymagane żadne dodatkowe odwołania:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>
    ...
</Project>
```

* Projekty, dla których docelowo `Microsoft.NET.Sdk` lub `Microsoft.NET.Sdk.Razor` SDK, powinny dodać jawne `FrameworkReference` do `Microsoft.AspNetCore.App`:

```xml
<Project Sdk="Microsoft.NET.Sdk.Razor">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>
    ...
</Project>
```

#### <a name="framework-dependent-builds-using-docker"></a>Kompilacje zależne od platformy przy użyciu platformy Docker

Kompilacje zależne od platformy, które korzystają z pakietu, który jest zależny od ASP.NET Core [udostępnionej platformy](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) mogą spowodować następujący błąd w czasie wykonywania:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App` to współdzielona struktura zawierająca środowisko uruchomieniowe ASP.NET Core i jest obecna tylko w obrazie platformy Dock [/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) .  Zestaw 3,0 SDK zmniejsza rozmiar kompilacji zależnych od platformy przy użyciu rdzenia asp.net, bez uwzględniania zduplikowanych kopii bibliotek, które są dostępne w strukturze udostępnionej.  Jest to potencjalne oszczędności do 18 MB, ale wymaga to, aby środowisko uruchomieniowe ASP.NET Core musi być obecne/zainstalowane w celu uruchomienia aplikacji.

Aby określić, czy aplikacja ma zależność (bezpośredni lub pośredni) w ASP.NET Core udostępnionej platformie, sprawdź plik *runtimeconfig. JSON* wygenerowany podczas kompilowania/publikowania aplikacji. Poniższy plik JSON przedstawia zależność od ASP.NET Core udostępnionej platformy:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Jeśli aplikacja korzysta z platformy Docker, Użyj obrazu podstawowego zawierającego ASP.NET Core 3,0. Na przykład `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Dodaj odwołania do pakietu dla usuniętych zestawów

ASP.NET Core 3,0 usuwa niektóre zestawy, które były wcześniej częścią odwołania do pakietu `Microsoft.AspNetCore.App`. Aby nadal korzystać z funkcji dostarczonych przez te zestawy, należy odwołać się do 3,0 wersji odpowiednich pakietów:

* Aplikacja internetowa wygenerowana przez szablon z **kontami poszczególnych użytkowników** wymaga dodania następujących pakietów:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft. EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Aby uzyskać więcej informacji na temat odwoływania się do pakietu specyficznego dla dostawcy bazy danych, zobacz [dostawcy bazy danych](/ef/core/providers/index).

* Interfejs użytkownika tożsamości

  Obsługę [interfejsu użytkownika tożsamości](xref:security/authentication/identity) można dodać, odwołując się do pakietu [Microsoft. AspNetCore. Identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* SPA usługi

  * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. SpaServices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Uwierzytelnianie &ndash; obsługa przepływów uwierzytelniania innych firm jest dostępna jako pakiety NuGet:

  * Protokół OAuth w serwisie Facebook ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Token okaziciela OpenID Connect Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Uwierzytelnianie konta Microsoft ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Uwierzytelnianie OpenID Connect Connect ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Protokół OAuth usługi Twitter ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Uwierzytelnianie WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Obsługa formatowania i negocjacji zawartości dla `System.Net.HttpClient` &ndash; pakiet NuGet [Microsoft. ASPNET. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) oferuje użyteczną rozszerzalność `System.Net.HttpClient` z interfejsami API, takimi jak `ReadAsAsync`, `PostJsonAsync` itd.

* Kompilacja środowiska uruchomieniowego Razor &ndash; obsługa kompilowania widoków i stron w środowisku uruchomieniowym jest teraz częścią [Microsoft. AspNetCore. MVC. Razor. RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* Obsługa platformy MVC `Newtonsoft.Json` &ndash; Obsługa używania MVC z `Newtonsoft.Json` jest teraz częścią [Microsoft. AspNetCore. MVC. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

## <a name="startup-changes"></a>Zmiany uruchamiania

Na poniższej ilustracji przedstawiono usunięte i zmienione wiersze w aplikacji internetowej ASP.NET Core 2,2 Razor Pages:

![usunięte i zmienione wiersze w aplikacji sieci Web ASP.NET Core Razor 2,2](22-to-30/_static/startup2.2.png)

Na powyższym obrazie usunięty kod jest wyświetlany na czerwono. W usuniętym kodzie nie są wyświetlane kody opcji plików cookie, które zostały usunięte przed porównaniem plików.

Na poniższej ilustracji przedstawiono dodane i zmienione wiersze w aplikacji internetowej ASP.NET Core 3,0 Razor Pages:

![dodane i zmienione wiersze w aplikacji sieci Web ASP.NET Core Razor 3,0](22-to-30/_static/startup3.0.png)

Na powyższym obrazie dodany kod jest wyświetlany w kolorze zielonym. Aby uzyskać informacje na temat następujących zmian:

* `services.AddMvc` do `services.AddRazorPages`, zobacz [Rejestrowanie usługi MVC](#mvc-service-registration) w tym dokumencie.
* `CompatibilityVersion`, zobacz <xref:mvc/compatibility-version>.
* `IHostingEnvironment` do `IWebHostEnvironment`, zobacz [ten anons](https://github.com/aspnet/AspNetCore/issues/7749)w witrynie GitHub.
* do szablonów dodano `app.UseAuthorization`, aby pokazać oprogramowanie pośredniczące do zatwierdzania zamówień. Jeśli aplikacja nie korzysta z autoryzacji, możesz bezpiecznie usunąć wywołanie `app.UseAuthorization`.
* `app.UseEndpoints`, zapoznaj się z tematem [Razor Pages](#razor-pages) lub [Migrowanie uruchamiania. Skonfiguruj](#migrate-startupconfigure) w tym dokumencie.

### <a name="analyzer-support"></a>Obsługa analizatora

Projekty, które są przeznaczone dla `Microsoft.NET.Sdk.Web` niejawnie przywoływanych analizatorów, które zostały wcześniej wysłane jako część pakietu [Microsoft. AspNetCore. MVC. analizatory](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . Nie są wymagane żadne dodatkowe odwołania, aby je włączyć.

Jeśli Twoja aplikacja używa [analizatorów interfejsów API](xref:web-api/advanced/analyzers) , które zostały wcześniej dostarczone przy użyciu pakietu [Microsoft. AspNetCore. MVC. API. analizatory](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , edytuj plik projektu, aby odwoływać się do analizatorów dostarczonych w ramach zestawu SDK sieci Web platformy .NET Core:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Biblioteka klas Razor

Projekty biblioteki klas Razor, które zapewniają składniki interfejsu użytkownika dla MVC, muszą ustawić właściwość `AddRazorSupportForMvc` w pliku projektu:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Model hostingu w procesie

Projekty są domyślne dla [modelu hostingu w procesie](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) w ASP.NET Core 3,0 lub nowszym. Opcjonalnie można usunąć Właściwość `<AspNetCoreHostingModel>` w pliku projektu, jeśli jej wartość to `InProcess`.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Konfiguracja

Migruj konfigurację Kestrel do konstruktora hosta sieci Web dostarczonego przez `ConfigureWebHostDefaults` (*program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Jeśli aplikacja ręcznie utworzy hosta z `HostBuilder`, wywołaj `UseKestrel` w konstruktorze hosta sieci Web w `ConfigureWebHostDefaults`:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Oprogramowanie pośredniczące połączenia zastępuje karty połączeń

Adaptery połączeń (<xref:Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter>) zostały usunięte z Kestrel. Zamień karty połączeń na oprogramowanie pośredniczące połączenia. Oprogramowanie pośredniczące połączenia jest podobne do oprogramowania pośredniczącego HTTP w potoku ASP.NET Core, ale dla połączeń niższego poziomu. Rejestrowanie protokołu HTTPS i połączeń:

* Zostały przeniesione z kart połączeń do oprogramowania pośredniczącego połączenia.
* Te metody rozszerzające działają tak jak w poprzednich wersjach ASP.NET Core. 

Aby uzyskać więcej informacji, zobacz [przykład TlsFilterConnectionHandler w sekcji ListenOptions. Protocols artykułu Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Abstrakcje transportu przenoszone i udostępniane publicznie

Warstwa transportu Kestrel została udostępniona jako interfejs publiczny w `Connections.Abstractions`. W ramach tych aktualizacji:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` i skojarzone typy zostały usunięte.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay> został przeniesiony z <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> do opcji transportu.
* <xref:Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode> został usunięty z <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>.

Aby uzyskać więcej informacji, zobacz następujące zasoby w witrynie GitHub:

* [Abstrakcje sieci klienta/serwera (ASPNET/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Zaimplementuj nowe abstrakcję odbiornika nimi i ponowne umieszczanie Kestrel na wierzchu (ASPNET/AspNetCore #10321)](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Nagłówki naczepy żądania Kestrel

Dla aplikacji przeznaczonych dla wcześniejszych wersji ASP.NET Core:

* Kestrel dodaje nagłówki przegałęzień protokołu HTTP/1.1 do kolekcji nagłówków żądań.
* Przyczepy są dostępne po odczytaniu treści żądania na końcu.

Powoduje to pewne wątpliwości dotyczące niejednoznaczności między nagłówkami i przyczepami, dlatego przyczepy zostały przeniesione do nowej kolekcji (`RequestTrailerExtensions`) w 3,0.

Żądania protokołu HTTP/2 są następujące:

* Niedostępne w ASP.NET Core 2,2.
* Dostępne w 3,0 jako `RequestTrailerExtensions`.

Nowe metody rozszerzenia żądania są obecne w celu uzyskania dostępu do tych przyczep. Podobnie jak w przypadku protokołu HTTP/1.1, przyczepy są dostępne po odczytaniu treści żądania na końcu.

W przypadku wydania 3,0 dostępne są następujące metody `RequestTrailerExtensions`:

* `GetDeclaredTrailers` &ndash; pobiera nagłówek żądania `Trailer`, który zawiera listę przyczep oczekiwanych po treści.
* `SupportsTrailers` &ndash; wskazuje, czy żądanie obsługuje nagłówki przyczepy.
* `CheckTrailersAvailable` &ndash; sprawdza, czy żądanie obsługuje przyczepy i czy są dostępne do odczytu. To sprawdzenie nie zakłada, że istnieją przyczepy do odczytu. Nie mogą być odczytywane przyczepy, nawet jeśli `true` jest zwracany przez tę metodę.
* `GetTrailer` &ndash; pobiera żądany końcowy nagłówek z odpowiedzi. Sprawdź `SupportsTrailers` przed wywołaniem `GetTrailer` lub <xref:System.NotSupportedException> mogą wystąpić, jeśli żądanie nie obsługuje końcowych nagłówków.

Aby uzyskać więcej informacji, zobacz [Umieszczanie przyczep żądań w oddzielnej kolekcji (ASPNET/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO wyłączone

`AllowSynchronousIO` włącza lub wyłącza synchroniczne interfejsy API we/wy, takie jak `HttpRequest.Body.Read`, `HttpResponse.Body.Write` i `Stream.Flush`. Te interfejsy API są źródłem zablokowania wątków prowadzącego do awarii aplikacji. W 3,0 `AllowSynchronousIO` jest domyślnie wyłączona. Aby uzyskać więcej informacji, zobacz [sekcję synchronicznej operacji we/wy w artykule Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Oprócz włączania `AllowSynchronousIO` z opcjami `ConfigureKestrel` synchroniczne operacje we/wy mogą być również zastępowane na podstawie żądania jako tymczasowe środki zaradcze:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Jeśli masz problemy z implementacjami <xref:System.IO.TextWriter> lub innymi strumieniami wywołującymi synchroniczne interfejsy API w operacji [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), zamiast tego wywołaj nowy interfejs API <xref:System.IO.Stream.DisposeAsync*>.

Aby uzyskać więcej informacji, zobacz [[anons] AllowSynchronousIO wyłączone na wszystkich serwerach (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Zestaw Microsoft. AspNetCore. Server. Kestrel. https został usunięty

W ASP.NET Core 2,1 zawartość *Microsoft. AspNetCore. Server. Kestrel. https. dll* została przeniesiona do pliku *Microsoft. AspNetCore. Server. Kestrel. Core. dll*. To była nieprzerwana Aktualizacja przy użyciu atrybutów `TypeForwardedTo`. W przypadku 3,0 został usunięty pusty zestaw *Microsoft. AspNetCore. Server. Kestrel. https. dll* oraz pakiet NuGet.

Biblioteki odwołujące się do [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) powinny aktualizować ASP.NET Core zależności do 2,1 lub nowszych.

Aplikacje i biblioteki ukierunkowane na ASP.NET Core 2,1 lub nowsze powinny usunąć wszystkie bezpośrednie odwołania do pakietu [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

## <a name="jsonnet-support"></a>Obsługa Json.NET

W ramach pracy w celu [usprawnienia ASP.NET Core udostępnionej struktury](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/) [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) został usunięty z ASP.NET Core udostępnionej platformy.

Wartość domyślna dla ASP.NET Core to teraz [System. Text. JSON](/dotnet/api/system.text.json?view=netcore-3.0), który jest nowy w programie .net Core 3,0. Rozważ użycie `System.Text.Json`, jeśli jest to możliwe. Jest wysoka wydajność i nie wymaga dodatkowej zależności biblioteki. Jednak, ponieważ `System.Text.Json` jest nowy, może obecnie nie mieć żadnych funkcji wymaganych przez aplikację.

Aplikacja może wymagać integracji `Newtonsoft.Json`, jeśli używa @no__t funkcji specyficznych dla -1, takich jak JsonPatch lub Converters, lub jeśli [formatuje](xref:web-api/advanced/formatting) @no__t typy specyficzne dla -3.

Aby użyć Json.NET w projekcie ASP.NET Core sygnalizującego 3,0, zobacz [Switch to Newtonsoft. JSON](#switch-to-newtonsoftjson) w tym dokumencie.

Aby użyć Json.NET w projekcie ASP.NET Core 3,0:

* Dodaj odwołanie do pakietu do [Microsoft. AspNetCore. MVC. NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Aktualizacja `Startup.ConfigureServices` w celu wywołania `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson` jest zgodna z nowymi metodami rejestracji usługi MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Ustawienia Json.NET można ustawić w wywołaniu `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Rejestracja usługi MVC

ASP.NET Core 3,0 dodaje nowe opcje rejestrowania scenariuszy MVC w ramach `Startup.ConfigureServices`.

Dostępne są trzy nowe metody rozszerzenia najwyższego poziomu związane z scenariuszami MVC na `IServiceCollection`. Szablony wykorzystują te nowe metody zamiast `AddMvc`. Jednak `AddMvc` nadal zachowuje się tak, jak w poprzednich wersjach.

Poniższy przykład dodaje obsługę kontrolerów i funkcji związanych z interfejsem API, ale nie widoków ani stron. Szablon interfejsu API używa tego kodu:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Poniższy przykład dodaje obsługę kontrolerów, funkcji związanych z interfejsem API i widoków, ale nie stron. Szablon aplikacji sieci Web (MVC) używa tego kodu:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Poniższy przykład dodaje obsługę Razor Pages i minimalną obsługę kontrolera. Szablon aplikacji sieci Web używa tego kodu:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Nowe metody można również łączyć. Poniższy przykład jest równoznaczny z wywołaniem `AddMvc` w ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Kod uruchomienia routingu

Jeśli aplikacja wywoła `UseMvc` lub `UseSignalR`, dokonaj migracji aplikacji do [routingu punktów końcowych](xref:fundamentals/routing) , jeśli to możliwe. Aby zwiększyć zgodność routingu punktów końcowych z poprzednimi wersjami MVC, zostały przywrócone niektóre zmiany w generowaniu adresów URL wprowadzone w ASP.NET Core 2,2. Jeśli wystąpią problemy z użyciem routingu punktów końcowych w 2,2, należy oczekiwać ulepszeń w ASP.NET Core 3,0 z następującymi wyjątkami:

* Jeśli aplikacja implementuje `IRouter` lub dziedziczy po `Route`, należy użyć [DynamicRouteValuesTransformer](https://github.com/aspnet/AspNetCore.Docs/issues/12997) jako zamiennika.

* Jeśli aplikacja bezpośrednio uzyskuje dostęp do `RouteData.Routers` wewnątrz MVC do analizy adresów URL, można go zastąpić przy użyciu `LinkParser.ParsePathByEndpointName`. 
 * Zdefiniuj trasę przy użyciu nazwy trasy.
 * Użyj `LinkParser.ParsePathByEndpointName` i przekaż żądaną nazwę trasy.

Routing punktów końcowych obsługuje tę samą składnię wzorca trasy i funkcje tworzenia wzorców tras jako `IRouter`. Routing punktów końcowych obsługuje `IRouteConstraint`. Routing punktów końcowych obsługuje `[Route]`, `[HttpGet]` i inne atrybuty routingu MVC.

W przypadku większości aplikacji tylko `Startup` wymaga wprowadzenia zmian.

### <a name="migrate-startupconfigure"></a>Migrowanie uruchamiania. Skonfiguruj

Ogólne porady:

* Dodaj `UseRouting`.
* Jeśli aplikacja wywołuje `UseStaticFiles`, należy umieścić `UseStaticFiles` **przed** `UseRouting`.
* Jeśli aplikacja używa funkcji uwierzytelniania/autoryzacji, takich jak `AuthorizePage` lub `[Authorize]`, należy umieścić wywołanie `UseAuthentication` i `UseAuthorization`: **After**, `UseRouting` i `UseCors`, ale przed `UseEndpoints`:

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Zastąp `UseMvc` lub `UseSignalR` z `UseEndpoints`.
* Jeśli aplikacja używa scenariuszy [CORS](xref:security/cors) , takich jak `[EnableCors]`, należy umieścić wywołanie do `UseCors` przed jakimkolwiek innym oprogramowanie pośredniczące używające mechanizmu CORS (na przykład umieścić `UseCors` przed `UseAuthentication`, `UseAuthorization` i `UseEndpoints`).
* Zastąp `IHostingEnvironment` z `IWebHostEnvironment` i Dodaj instrukcję `using` dla przestrzeni nazw <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>.
* Zastąp `IApplicationLifetime` z <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (przestrzeń nazw <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>).
* Zastąp `EnvironmentName` z <xref:Microsoft.Extensions.Hosting.Environments> (przestrzeń nazw <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>).

Poniższy kod jest przykładem `Startup.Configure` w typowej aplikacji ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Po zaktualizowaniu poprzedniego kodu `Startup.Configure`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> W przypadku większości aplikacji wywołania do `UseAuthentication`, `UseAuthorization` i `UseCors` muszą występować między wywołaniami do `UseRouting` i `UseEndpoints`, aby obowiązywały.

### <a name="health-checks"></a>Kontrole kondycji

Kontrole kondycji korzystają z routingu punktu końcowego z hostem ogólnym. W `Startup.Configure` Wywołaj `MapHealthChecks` w konstruktorze punktów końcowych z adresem URL punktu końcowego lub ścieżką względną:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Punkty końcowe sprawdzania kondycji mogą:

* Określ jeden lub więcej dozwolonych hostów/portów.
* Wymagaj autoryzacji.
* Wymagaj mechanizmu CORS.

Aby uzyskać więcej informacji, zobacz <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Wskazówki dotyczące oprogramowania pośredniczącego zabezpieczeń

Obsługa autoryzacji i mechanizmu CORS jest ujednolicona dla podejścia [pośredniczącego](xref:fundamentals/middleware/index) . Pozwala to korzystać z tego samego oprogramowania pośredniczącego i funkcji w tych scenariuszach. Zaktualizowane oprogramowanie pośredniczące autoryzacji jest dostępne w tej wersji, a oprogramowanie do obsługi mechanizmu CORS jest ulepszone, aby można było zrozumieć atrybuty używane przez kontrolery MVC.

#### <a name="cors"></a>SPECYFIKACJI

Wcześniej mechanizm CORS może być trudny do skonfigurowania. Oprogramowanie pośredniczące zostało dostarczone do użycia w niektórych przypadkach użycia, ale filtry MVC były przeznaczone do użycia **bez** oprogramowania pośredniczącego w innych przypadkach użycia. W ASP.NET Core 3,0 zalecamy, aby wszystkie aplikacje wymagające mechanizmu CORS korzystały z oprogramowania pośredniczącego CORS wspólnie z routingiem punktów końcowych. `UseCors` można podać przy użyciu domyślnych zasad, a w razie potrzeby można użyć atrybutów `[EnableCors]` i `[DisableCors]`.

W poniższym przykładzie:

* Funkcja CORS jest włączona dla wszystkich punktów końcowych z nazwanymi zasadami `default`.
* Klasa `MyController` wyłącza funkcję CORS z atrybutem `[DisableCors]`.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autoryzacja

We wcześniejszych wersjach ASP.NET Core Obsługa autoryzacji była świadczona za pośrednictwem atrybutu `[Authorize]`. Oprogramowanie pośredniczące autoryzacji nie jest dostępne. W ASP.NET Core 3,0 wymagane jest oprogramowanie pośredniczące autoryzacji. Zalecamy umieszczenie oprogramowania pośredniczącego autoryzacji ASP.NET Core (`UseAuthorization`) zaraz po `UseAuthentication`. Oprogramowanie pośredniczące autoryzacji można także skonfigurować przy użyciu zasad domyślnych, które mogą zostać zastąpione.

W ASP.NET Core 3,0 lub nowszej `UseAuthorization` jest wywoływana w `Startup.Configure`, a następujący `HomeController` wymaga zalogowanego użytkownika:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Jeśli aplikacja używa `AuthorizeFilter` jako filtru globalnego w MVC, zalecamy refaktoryzację kodu w celu zapewnienia zasad w wywołaniu `AddAuthorization`.

@No__t-0 jest początkowo skonfigurowana do wymagania uwierzytelniania, dlatego nie jest wymagana żadna dodatkowa konfiguracja. W poniższym przykładzie punkty końcowe MVC są oznaczone jako `RequireAuthorization`, aby wszystkie żądania musiały być autoryzowane na podstawie `DefaultPolicy`. Jednak `HomeController` zezwala na dostęp bez logowania użytkownika do aplikacji z powodu `[AllowAnonymous]`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Zasady można także dostosować. Po powyższym przykładzie `DefaultPolicy` jest skonfigurowany do wymagania uwierzytelniania i określonego zakresu:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Alternatywnie można skonfigurować wszystkie punkty końcowe, aby wymagać autoryzacji bez `[Authorize]` lub `RequireAuthorization` przez skonfigurowanie `FallbackPolicy`. @No__t-0 różni się od `DefaultPolicy`. @No__t-0 jest wyzwalana przez `[Authorize]` lub `RequireAuthorization`, podczas gdy `FallbackPolicy` jest wyzwalana, gdy nie ustawiono żadnych innych zasad. `FallbackPolicy` jest początkowo skonfigurowany do zezwalania na żądania bez autoryzacji.

Poniższy przykład jest taki sam jak poprzedni `DefaultPolicy` przykład, ale używa `FallbackPolicy`, aby zawsze wymagał uwierzytelniania we wszystkich punktach końcowych, z wyjątkiem sytuacji, gdy `[AllowAnonymous]` jest określony:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Autoryzacja przez oprogramowanie pośredniczące działa bez struktury, która ma konkretną wiedzę o autoryzacji. Na przykład [kontrole kondycji](xref:host-and-deploy/health-checks) nie mają określonej znajomości autoryzacji, ale kontrole kondycji mogą mieć konfigurowalne zasady autoryzacji stosowane przez oprogramowanie pośredniczące.

Ponadto każdy punkt końcowy może dostosować wymagania dotyczące autoryzacji. W poniższym przykładzie `UseAuthorization` przetwarza autoryzację z `DefaultPolicy`, ale punkt końcowy sprawdzania kondycji `/healthz` wymaga użytkownika `admin`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Ochrona jest zaimplementowana w niektórych scenariuszach. Punkty końcowe oprogramowanie pośredniczące zgłasza wyjątek, jeśli zasady autoryzacji lub mechanizmu CORS zostały pominięte ze względu na brak oprogramowania pośredniczącego. Obsługa analizatora, aby zapewnić dodatkową opinię na temat niedziałania konfiguracji.

### <a name="signalr"></a>SignalR

Mapowanie centrów sygnałów teraz odbywa się w `UseEndpoints`.

Mapuj każde centrum z `MapHub`. Tak jak w poprzednich wersjach, każde centrum jest jawnie wymienione.

W poniższym przykładzie dodano obsługę centrum sygnałów `ChatHub`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Istnieje nowa opcja kontrolowania limitów rozmiaru komunikatów od klientów. Na przykład w `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

W ASP.NET Core 2,2 można ustawić `TransportMaxBufferSize` i efektywnie kontrolować maksymalny rozmiar komunikatu. W ASP.NET Core 3,0 ta opcja teraz kontroluje maksymalny rozmiar tylko przed zaobserwowaniem wartości.

### <a name="mvc-controllers"></a>Kontrolery MVC

Teraz mapowanie kontrolerów odbywa się w `UseEndpoints`.

Dodaj `MapControllers`, jeśli aplikacja używa routingu atrybutów. Ponieważ Routing obejmuje obsługę wielu struktur w ASP.NET Core 3,0 lub nowszych, Dodawanie kontrolerów z obsługą atrybutu jest zgodą.

Zastąp następujące:

* `MapRoute` z `MapControllerRoute`
* `MapAreaRoute` z `MapAreaControllerRoute`

Ponieważ Routing obejmuje teraz obsługę więcej niż tylko MVC, terminologia zmieniła się w taki sposób, że te metody jasno określają to, co robią. Trasy konwencjonalne, takie jak `MapControllerRoute` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 są stosowane w kolejności, w jakiej zostały dodane. Najpierw umieść bardziej szczegółowe trasy (takie jak trasy dla obszaru).

W poniższym przykładzie:

* `MapControllers` dodaje obsługę kontrolerów z routingiem z atrybutami.
* `MapAreaControllerRoute` dodaje konwencjonalne trasy dla kontrolerów w obszarze.
* `MapControllerRoute` dodaje konwencjonalne trasy dla kontrolerów.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Usuwanie sufiksu asynchronicznego z nazw akcji kontrolera

W ASP.NET Core 3,0, ASP.NET Core MVC usuwa sufiks `Async` z nazw akcji kontrolera. Ta nowa wartość domyślna ma wpływ na generowanie routingu i linków. Na przykład:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Przed ASP.NET Core 3,0:

* Do powyższej akcji można uzyskać dostęp w marszrucie *produkty/ListAsync* .
* Wymagana jest generacja linku określająca sufiks `Async`. Na przykład:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

W ASP.NET Core 3,0:

* Poprzednią akcję można uzyskać przy użyciu trasy *produkty/lista* .
* Generowanie łącza nie wymaga określenia sufiksu `Async`. Na przykład:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Ta zmiana nie ma wpływu na nazwy określone przy użyciu atrybutu [[ActionName]](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) . Zachowanie domyślne można wyłączyć przy użyciu następującego kodu w `Startup.ConfigureServices`:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

### <a name="razor-pages"></a>Razor Pages

Mapowanie Razor Pages teraz odbywa się w `UseEndpoints`.

Dodaj `MapRazorPages`, jeśli aplikacja używa Razor Pages. Ponieważ Routing punktów końcowych obejmuje obsługę wielu struktur, dodanie Razor Pages jest teraz zgodą.

W następującej metodzie `Startup.Configure` `MapRazorPages` dodaje obsługę Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Korzystanie z MVC bez routingu punktu końcowego

Użycie MVC za pośrednictwem `UseMvc` lub `UseMvcWithDefaultRoute` w ASP.NET Core 3,0 wymaga jawnej zgody w ramach `Startup.ConfigureServices`. Jest to wymagane, ponieważ MVC musi wiedzieć, czy może polegać na oprogramowaniu pośredniczącym i oprogramowaniu CORS podczas inicjacji. Zostanie dostarczony Analizator ostrzegający, czy aplikacja próbuje użyć nieobsługiwanej konfiguracji.

Jeśli aplikacja wymaga starszej obsługi `IRouter`, wyłącz `EnableEndpointRouting` przy użyciu dowolnych z następujących metod w `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Kontrole kondycji

Kontrole kondycji mogą służyć jako oprogramowanie *do przesyłania i kierowania* punktów końcowych.

Dodaj `MapHealthChecks`, aby użyć kontroli kondycji z routingiem punktów końcowych. Metoda `MapHealthChecks` akceptuje argumenty podobne do `UseHealthChecks`. Zaletą korzystania z `MapHealthChecks` za pośrednictwem `UseHealthChecks` jest możliwość zastosowania autoryzacji i zwiększenia szczegółowej kontroli nad pasującymi zasadami.

W poniższym przykładzie `MapHealthChecks` jest wywoływana dla punktu końcowego sprawdzania kondycji w `/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder zastępuje WebHostBuilder

Szablony ASP.NET Core 3,0 korzystają z [hosta ogólnego](xref:fundamentals/host/generic-host). Poprzednie wersje używają [hosta sieci Web](xref:fundamentals/host/web-host). Poniższy kod przedstawia szablon ASP.NET Core 3,0 wygenerowany `Program` klasy:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Poniższy kod przedstawia ASP.NET Core 2,2 generowany przez szablon `Program` klasy:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> pozostaje w 3,0 i jest typem `webBuilder` widocznym w poprzednim przykładzie kodu. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> będzie przestarzałe w przyszłej wersji i zastąpione przez `HostBuilder`.

Najbardziej znacząca zmiana z `WebHostBuilder` do `HostBuilder` jest [iniekcją zależności (di)](xref:fundamentals/dependency-injection). W przypadku używania `HostBuilder` można wstrzyknąć tylko <xref:Microsoft.Extensions.Configuration.IConfiguration> i <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> do konstruktora `Startup`. Ograniczenia `HostBuilder` DI:

* Zezwól na kompilowanie kontenera DI tylko raz.
* Pozwala uniknąć problemów z okresem istnienia obiektów, takich jak rozpoznawanie wielu wystąpień pojedynczych.

## <a name="addauthorization-moved-to-a-different-assembly"></a>Element addauthorization został przeniesiony do innego zestawu

ASP.NET Core 2,2 i niższe metody `AddAuthorization` w *pliku Microsoft. AspNetCore. Authorization. dll*:

* Zmieniono nazwę `AddAuthorizationCore`.
* Zostały przeniesione do *pliku Microsoft. AspNetCore. Authorization. Policy. dll*.

Nie ma to wpływu na aplikacje, które korzystają z plików *Microsoft. AspNetCore. Authorization. dll* i *Microsoft. AspNetCore. Authorization. Policy. dll* .

Aplikacje, które nie korzystają z *programu Microsoft. AspNetCore. Authorization. Policy. dll* , powinny wykonać jedną z następujących czynności:

* Przełącz do korzystania z `AddAuthorizationCore`
* Dodaj odwołanie do *pliku Microsoft. AspNetCore. Authorization. Policy. dll*.

Aby uzyskać więcej informacji, zobacz temat [zmiana w `AddAuthorization(o =>`) okres przeciążenia w innym #386 zestawu](https://github.com/aspnet/Announcements/issues/386).

## <a name="signalr"></a>SignalR

Klient JavaScript sygnalizujący zmienił się z `@aspnet/signalr` na `@microsoft/signalr`. Aby reagować na tę zmianę, Zmień odwołania w plikach *Package. JSON* , instrukcje `require` i instrukcje języka ECMAScript `import`.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON jest domyślnym protokołem

`System.Text.Json` jest teraz domyślnym protokołem centrum używanym przez klienta i serwer.

W `Startup.ConfigureServices` Wywołaj `AddJsonProtocol`, aby ustawić opcje serializatora.

**Server**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Klient:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Przejdź do pliku Newtonsoft. JSON

Jeśli używasz funkcji programu `Newtonsoft.Json`, które nie są obsługiwane w `System.Text.Json`, możesz przełączyć się z powrotem do `Newtonsoft.Json`:

1. Zainstaluj pakiet NuGet [Microsoft. AspNetCore. Signal. Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. Na kliencie należy utworzyć łańcuch wywołania metody `AddNewtonsoftJsonProtocol` do wystąpienia `HubConnectionBuilder`:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Na serwerze należy utworzyć łańcuch wywołania metody `AddNewtonsoftJsonProtocol` do wywołania metody `AddSignalR` w `Startup.ConfigureServices`:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Zezwól na kompilację środowiska uruchomieniowego

Przed ASP.NET Core 3,0, kompilacja widoków w środowisku uruchomieniowym była niejawną funkcją struktury. Kompilacja środowiska uruchomieniowego uzupełnia kompilację widoków w czasie kompilacji. Pozwala ona na kompilowanie widoków i stron Razor (pliki *. cshtml* ), gdy pliki są modyfikowane, bez konieczności ponownego kompilowania całej aplikacji. Ta funkcja obsługuje scenariusz tworzenia szybkiej edycji w środowisku IDE i odświeżania przeglądarki w celu wyświetlenia zmian.

W ASP.NET Core 3,0, Kompilacja środowiska uruchomieniowego jest scenariuszem wyboru. Kompilacja czasu kompilacji jest jedynym mechanizmem kompilacji, który jest domyślnie włączony. Środowisko uruchomieniowe korzysta z programu Visual Studio lub [dotnet-Watch](xref:tutorials/dotnet-watch) w Visual Studio Code, aby ponownie skompilować projekt po wykryciu zmian w plikach *. cshtml* . W programie Visual Studio zmiany w plikach *CS*, *cshtml*lub *. Razor* w projekcie są uruchamiane (<kbd>Ctrl + F5</kbd>), ale nie są debugowane (<kbd>F5</kbd>), wyzwalają ponowną kompilację projektu.

Aby włączyć kompilację środowiska uruchomieniowego w projekcie ASP.NET Core 3,0:

1. Zainstaluj pakiet NuGet [Microsoft. AspNetCore. MVC. Razor. RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) .
1. Aktualizacja `Startup.ConfigureServices` w celu wywołania `AddRazorRuntimeCompilation`:

    W przypadku ASP.NET Core MVC Użyj następującego kodu:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    W przypadku Razor Pages ASP.NET Core Użyj następującego kodu:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
Przykład w https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation pokazuje przykładowy sposób włączania kompilacji środowiska uruchomieniowego w środowiskach deweloperskich.

Aby uzyskać więcej informacji na temat kompilacji pliku Razor, zobacz <xref:mvc/views/view-compilation>.

## <a name="migrate-libraries-via-multi-targeting"></a>Migrowanie bibliotek poprzez wiele elementów docelowych

Biblioteki często muszą obsługiwać wiele wersji ASP.NET Core. Większość bibliotek, które zostały skompilowane przed poprzednimi wersjami ASP.NET Core, powinna działać bez problemów. Następujące warunki wymagają, aby aplikacja była skompilowana w sposób krzyżowy:

* Biblioteka korzysta z funkcji, która ma istotną [zmianę](#breaking-api-changes)w postaci binarnej.
* Biblioteka chce korzystać z nowych funkcji w ASP.NET Core 3,0. 

Na przykład:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Użyj `#ifdefs`, aby włączyć interfejsy API specyficzne dla ASP.NET Core 3,0:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

### <a name="publish"></a>Wycofywan

Usuń foldery *bin* i *obj* w katalogu projektu.

<a name="break"></a>

## <a name="breaking-api-changes"></a>Przerywanie zmian interfejsu API

Przejrzyj istotne zmiany:

* [Pełna lista istotnych zmian w wersji 3,0 ASP.NET Core](https://github.com/aspnet/Announcements/issues?page=2&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Przerywanie zmian interfejsu API w ramach funkcji "antysfałszowanych", mechanizmu CORS, diagnostyki, MVC i routingu](https://github.com/aspnet/Announcements/issues/387). Ta lista zawiera istotne zmiany dotyczące przełączników zgodności.
* Aby uzyskać podsumowanie dotyczące podziału od 2,2 do 3,0 na platformie .NET Core, ASP.NET Core i Entity Framework Core, zobacz istotne [zmiany dotyczące migracji z wersji 2,2 do 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="aspnet-core-30-not-currently-available-for-azure-app-service"></a>ASP.NET Core 3,0 nie jest obecnie dostępna dla Azure App Service

Mamy nadzieję, że udostępnimy to wkrótce. Dopóki ASP.NET Core 3,0 jest dostępny w Azure App Service, postępuj zgodnie z instrukcjami podanymi w tematach [wdrażanie ASP.NET Core wersja zapoznawcza do Azure App Service](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).

## <a name="mysqldataentityframeworkcore-not-currently-supported-on-aspnet-core-30"></a>Produkty MySql. Data. EntityFrameworkCore nie są obecnie obsługiwane w ASP.NET Core 3,0

Aby uzyskać więcej informacji, zobacz [ten problem](https://github.com/aspnet/EntityFrameworkCore/issues/17788)w serwisie GitHub.
