---
title: Migrowanie z programu ASP.NET Core 2.2 i 3.0 (wersja zapoznawcza)
author: tdykstra
description: Dowiedz się, jak przeprowadzić migrację projektu programu ASP.NET Core 2.2 do platformy ASP.NET Core 3.0.
ms.author: tdykstra
ms.custom: mvc
ms.date: 05/09/2019
uid: migration/22-to-30
ms.openlocfilehash: 7c47d042749ac3960c301ad918858e0375f4b2d0
ms.sourcegitcommit: 20ca93d72cb0b3998637724b44523e57b089c8fd
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/09/2019
ms.locfileid: "65473576"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migracja z programu ASP.NET Core 2.2 lub 3.0

Przez [Scott Addie](https://github.com/scottaddie) i [Rick Anderson](https://twitter.com/RickAndMSFT)

W tym artykule wyjaśniono, jak zaktualizować istniejący projekt ASP.NET Core 2.2 do platformy ASP.NET Core 3.0.

[!INCLUDE[](~/includes/net-core-prereqs-all-3.0.md)]

## <a name="update-the-project-file"></a>Należy zaktualizować plik projektu

* Ustaw [docelowe Moniker struktury (TFM)](/dotnet/standard/frameworks#referring-to-frameworks) do `netcoreapp3.0`:

  ```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
  ```

* Usuń wszystkie `<PackageReference>` do [pakiet](xref:fundamentals/metapackage) lub [Microsoft.AspNetCore.App](xref:fundamentals/metapackage-app) meta Microsoft.aspnetcore.all.

* Aktualizacja `Version` na pozostałe `<PackageReference>` elementy `Microsoft.AspNetCore.*` pakietów do bieżącej wersji zapoznawczej (na przykład `3.0.0-preview-18579-0053`).

  Jeśli nie ma wersji 3.0 pakietu, pakietu może zostały zaniechane w 3.0. Wiele z nich są częścią `Microsoft.AspNetCore.App` i nie powinien odwoływać się oddzielnie. Aby wstępną listę pakietów, które nie są już utworzone w 3.0, zobacz [rezygnują pakietów zestawy udostępnionych framework 3.0 (aspnet/AspNetCore #3756)](https://github.com/aspnet/AspNetCore/issues/3756). *Udostępnionej platformy* to zbiór zestawów (*.dll* plików), są zainstalowane na komputerze i odwołuje się `Microsoft.AspNetCore.App`. Aby uzyskać więcej informacji, zobacz [udostępnionej platformy](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Niektóre zestawy zostały usunięte z `Microsoft.AspNetCore.App` między 2.x i 3.0. Może być konieczne dodanie `<PackageReference>` elementy z pakiety wymienione w przypadku używania interfejsów API [zestawy usuwany z Microsoft.AspNetCore.App 3.0 (aspnet/AspNetCore #3755)](https://github.com/aspnet/AspNetCore/issues/3755).

  Na przykład `Microsoft.EntityFrameworkCore` i `System.Data.SqlClient` są już częścią `Microsoft.AspNetCore.App`. Lista zestawów w wysyłki `Microsoft.AspNetCore.App` nie została jeszcze zakończona i zmieni się przed RTM w wersji 3.0.

* Dodaj [pomocy technicznej na składnik Json.NET](#jsonnet-support).

* Domyślnie projekty [modelu hostingu w trakcie](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) w programie ASP.NET Core 3.0 lub nowszej. Możesz opcjonalnie usunąć `<AspNetCoreHostingModel>` właściwość w pliku projektu, gdy jego wartość jest `InProcess`.

## <a name="jsonnet-support"></a>Obsługa Json.NET

Jako część pracy [poprawić udostępnionej platformy ASP.NET Core](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), [Json.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) została usunięta z udostępnionej platformy ASP.NET Core.

Aby użyć struktury Json.NET w projektach programu ASP.NET Core 3.0 to:

* Dodaj odwołanie do pakietu [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Aktualizacja `Startup.ConfigureServices` do wywołania `AddNewtonsoftJson()`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  Można skonfigurować ustawienia Newtonsoft z `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Rejestracja usługi MVC

Platforma ASP.NET Core 3.0 dodaje nowe opcje rejestrowania MVC scenariusze wewnątrz `Startup.ConfigureServices`.

Trzy nowe metody rozszerzenie najwyższego poziomu związane z MVC scenariuszy na `IServiceCollection` są dostępne. Szablony używają tych nowych metod zamiast `UseMvc`. Jednak `AddMvc` będzie nadal działać, ponieważ zawiera ona w poprzednich wersjach.

Poniższy przykład dodaje obsługę kontrolerów oraz funkcjach interfejsu API, ale nie widoki lub strony. Szablon interfejsu API korzysta z tego kodu:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Poniższy przykład dodaje obsługę kontrolerów, funkcjach interfejsu API i widoki, ale nie stron. Szablon aplikacji sieci Web (MVC) korzysta z tego kodu:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Poniższy przykład dodaje obsługę dla stron Razor i minimalne kontrolera. Ten kod korzysta z szablonu aplikacji sieci Web:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Można również łączyć nowych metod. Poniższy przykład jest równoważne z wywoływaniem `AddMvc` w programie ASP.NET Core 2.2: 

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
    services.AddRazorPages();
}
```

## <a name="update-routing-startup-code"></a>Zaktualizuj kod uruchamiający routingu

Jeśli aplikacja wywołuje `UseMvc` lub `UseSignalR`, migrowanie aplikacji na [routingu punkt końcowy](xref:fundamentals/routing) , jeśli jest to możliwe. Aby zwiększyć routingu punkt końcowy zgodność z poprzednimi wersjami programu MVC, firma Microsoft został przywrócony niektóre ze zmian podczas generowania adresu URL wprowadzony w programie ASP.NET Core 2.2. Jeśli wystąpił problemów przy użyciu routingu punkt końcowy w 2.2 oczekiwać od ulepszeń platformy ASP.NET Core 3.0 to z następującymi wyjątkami:

* Jeśli aplikacja korzysta `IRouter` lub dziedziczy `Route`, możesz uniknąć migracji w tej chwili. Wyrażenie opinii na [zaplanować migrację implementacje IRouter oparte na punkt końcowy routingu](https://github.com/aspnet/AspNetCore/issues/4221).

* Jeśli aplikacja korzysta bezpośrednio `RouteData.Routers` wewnątrz MVC, możesz uniknąć migracji w tej chwili. Wyrażenie opinii na [migracji wskazówki dotyczące używania RouteData.Routers](https://github.com/aspnet/AspNetCore/issues/9148).

Routing do Endpoint obsługuje tej samej składni wzorzec trasy i wzorzec trasy funkcji jako tworzenia `IRouter`. Obsługa routingu punkt końcowy `IRouteContraint`. Obsługa routingu punkt końcowy `[Route]`, `[HttpGet]`i inne atrybuty routingu MVC.

W przypadku większości aplikacji tylko `Startup` wymaga wprowadzenia zmian.

### <a name="migrate-startupconfigure"></a>Migrowanie Startup.Configure

Ogólne porady dotyczące:

* Dodaj `UseRouting`. 
* Jeśli aplikacja wywołuje `UseStaticFiles`, umieść `UseStaticFiles` **przed** `UseRouting`.
* Jeśli aplikacja używa funkcji uwierzytelniania/autoryzacji `AuthorizePage` lub `[Authorize]`, Umieść wywołanie `UseAuthentication` i `UseAuthorization` **po** `UseRouting`.
* Jeśli aplikacja korzysta z [CORS](xref:security/cors) funkcje, takie jak `[EnableCors]`, umieść `UseCors` dalej.
* Zastąp `UseMvc` lub `UseSignalR` z `UseEndpoints`.

Oto przykład `Startup.Configure` w typowej aplikacji platformy ASP.NET Core 2.2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();
    
    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Po zaktualizowaniu poprzedniego `Startup.Configure` kodu:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();
    
    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();
    app.UseCors();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="security-middleware-guidance"></a>Wskazówki dotyczące zabezpieczeń oprogramowania pośredniczącego

Obsługa autoryzacji i mechanizmu CORS jest jednolita wokół [oprogramowania pośredniczącego](xref:fundamentals/middleware/index) podejście. Umożliwia to korzystanie z tego samego oprogramowania pośredniczącego i funkcje w tych scenariuszach. Oprogramowanie pośredniczące zaktualizowane autoryzacji znajduje się w tej wersji, a oprogramowanie pośredniczące CORS został rozszerzony tak, aby go zrozumieć atrybutów kontrolerów MVC.

#### <a name="cors"></a>CORS

Wcześniej CORS może być trudne do skonfigurowania. Oprogramowanie pośredniczące podano do użycia w niektórych przypadkach użycia, ale MVC filtry zostały przeznaczone do użycia **bez** oprogramowania pośredniczącego w innych przypadkach użycia. Za pomocą platformy ASP.NET Core 3.0 to zalecane, wszystkie aplikacje, które wymagają mechanizmu CORS użycie oprogramowanie pośredniczące CORS wraz z routingiem punktu końcowego. `UseCors` można podać domyślną zasadę i `[EnableCors]` i `[DisableCors]` atrybuty można zastąpić domyślne zasady gdy jest to wymagane. 

W poniższym przykładzie:

* Mechanizm CORS jest włączona dla wszystkich punktów końcowych przy użyciu `default` o nazwie zasady.
* `MyController` Klasy wyłącza mechanizm CORS za pomocą `[DisableCors]` atrybutu.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default"); 

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autoryzacja

We wcześniejszych wersjach programu ASP.NET Core, obsługę autoryzacji podano za pośrednictwem `[Authorize]` atrybutu. Oprogramowanie pośredniczące autoryzacji nie była dostępna. W programie ASP.NET Core 3.0 autoryzacji w oprogramowaniu pośredniczącym jest wymagana. Zaleca się umieszczenie oprogramowania pośredniczącego autoryzacji (`UseAuthentication`) bezpośrednio przed `UseAuthorization`. Oprogramowanie pośredniczące autoryzacji można również skonfigurować domyślną zasadę, która może być zastąpiona.

W programie ASP.NET Core 3.0 lub nowszej `UseAuthorization` jest wywoływana w `Startup.Configure`, następujący kod `HomeController` wymaga podpisanego przez użytkownika:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Jeśli aplikacja korzysta z `AuthorizeFilter` jako globalny filtr w MVC, firma Microsoft zaleca, Refaktoryzacja kodu w celu zapewnienia zasad w celu `UseAuthorization` oprogramowania pośredniczącego.

W poniższym przykładzie, niestandardowe zasady mają być stosowane do wszystkich żądań, gdy `UseAuthorization` nosi nazwę, a `HomeController` zezwala na dostęp bez użytkownika, logując się do aplikacji:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization(new AuthorizationPolicyBuilder().Build()));

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Autoryzacja przez oprogramowanie pośredniczące działa bez framework posiadanie żadnej szczególnej wiedzy autoryzacji. Na przykład [kontrole kondycji](xref:host-and-deploy/health-checks) nie ma określonych informacji o autoryzacji, ale kontrole kondycji może mieć zasady autoryzacji można konfigurować stosowane przez oprogramowanie pośredniczące.

W poniższym przykładzie `UseAuthorization` przetwarza autoryzacji bez zasad domyślnych, ale `/healthz` punkt końcowy kontroli kondycji wymaga od użytkownika w `admin` roli: 

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Ochrona jest zaimplementowana w niektórych scenariuszach. `UseEndpoint` oprogramowanie pośredniczące zgłasza wyjątek, jeśli autoryzacji lub zasady CORS zostało pominięte ze względu na brak oprogramowania pośredniczącego. Obsługa analizatora, aby zapewnić dodatkową opinię na temat błędnej konfiguracji jest w toku.

### <a name="migrate-signalr"></a>Migrowanie SignalR

Mapowania koncentratorów SignalR teraz ma miejsce w obrębie `UseEndpoints`. 

Mapowanie każdego Centrum z `MapHub`. Tak jak w poprzednich wersjach znajduje się jawnie każdego Centrum.

W poniższym przykładzie obsługa `ChatHub` Centrum SignalR zostanie dodany:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

### <a name="migrate-mvc-controllers"></a>Migrowanie kontrolerów MVC

Mapowanie kontrolerów teraz ma miejsce w obrębie `UseEndpoints`. 

Dodaj `MapControllers` Jeśli aplikacja korzysta z trasami atrybutów. Ponieważ routing obejmuje obsługę wielu platform w programie ASP.NET Core 3.0 lub nowszej, dodanie kontrolerów kierowane atrybutu jest zoptymalizowany pod kątem. 

Zastąp następujące czynności:

* `MapRoute` za pomocą `MapControllerRoute`
* `MapAreaRoute` za pomocą `MapAreaControllerRoute`

Ponieważ routingu teraz obejmuje obsługę więcej niż tylko MVC, terminologii zmienił się z tych metod, wyraźnie określają, co robią. Konwencjonalne tras `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` są stosowane w kolejności, są one dodawane. Najpierw umieścić trasy bardziej szczegółowe (na przykład trasy dla obszaru).

W poniższym przykładzie:

* `MapControllers` dodaje obsługę kontrolerów kierowane atrybutu.
* `MapAreaControllerRoute` dodaje konwencjonalne trasę dla kontrolerów, w obszarze.
* `MapControllerRoute` Dodaje trasę konwencjonalne kontrolerów.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin", 
            "admin", 
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="migrate-razor-pages"></a>Migrowanie stron Razor

Teraz mapowanie stron Razor odbywa się wewnątrz `UseEndpoints`.

Dodaj `MapRazorPages` Jeśli aplikacja korzysta z stron Razor. Ponieważ routingu punkt końcowy obejmuje obsługę wielu platform, dodawanie stron Razor jest teraz uczestnictwo.

W poniższym przykładzie `MapRazorPages` dodano obsługę stron Razor:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Korzystania z aplikacji MVC bez punktu końcowego routingu

Za pomocą MVC za pomocą `UseMvc` lub `UseMvcWithDefaultRoute` w ASP.NET Core 3.0 wymaga jawnej zgody na uczestnictwo w `Startup.ConfigureServices`. Jest to wymagane, ponieważ MVC musisz wiedzieć, czy jego opierają się na autoryzacji i oprogramowanie pośredniczące CORS podczas inicjowania. Analizator jest warunkiem, że ostrzega, gdy aplikacja próbuje użyć nieobsługiwaną konfigurację.

Jeśli aplikacja wymaga starsza wersja `IRouter` pomocy technicznej, wyłącz `EnableEndpointRouting` przy użyciu dowolnej z następujących zbliża się w `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="migrate-health-checks"></a>Migrowanie z kontroli kondycji

Kontrole kondycji mogą być używane jako *złośliwego oprogramowania na routerze* z routingiem punktu końcowego.

Dodaj `MapHealthChecks` używać kondycji sprawdza, czy punkt końcowy routingu. `MapHealthChecks` Metoda akceptuje argumenty, podobnie jak `UseHealthChecks`. Zaletą korzystania z `MapHealthChecks` za pośrednictwem `UseHealthChecks` jest możliwość zastosowania autoryzacji i mają większy precyzyjną kontrolę nad odpowiednich zasad. 

W poniższym przykładzie `MapHealthChecks` nosi nazwę punktu końcowego sprawdzania kondycji na `/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>Zastępuje HostBuilder WebHostBuilder

Szablony ASP.NET Core 3.0 używają [ogólnego hosta](xref:fundamentals/host/generic-host). Poprzednie wersje używane [hosta sieci Web](xref:fundamentals/host/web-host). Poniższy kod przedstawia wygenerowanego szablonu platformy ASP.NET Core 3.0 `Program` klasy:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Poniższy kod przedstawia platformy ASP.NET Core 2.2, wygenerowany szablon `Program` klasy:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> pozostaje w 3.0 i jest typem `webBuilder` widoczne w poprzednim przykładzie kodu. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> zostanie uznane za przestarzałe w przyszłych wydaniach i zastąpione przez `HostBuilder`.

Najbardziej znaczące zmiany z `WebHostBuilder` do `HostBuilder` znajduje się w [wstrzykiwanie zależności (DI)](xref:fundamentals/dependency-injection). Korzystając z `HostBuilder`, może tylko wprowadzać <xref:Microsoft.Extensions.Configuration.IConfiguration> i <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> do `Startup`przez Konstruktor. `HostBuilder` DI ograniczenia:

* Włącz kontenera DI ma zostać utworzony tylko jeden raz.
* Pozwala uniknąć wynikowy kwestie istnienia obiektu, takie jak rozwiązywanie wielu wystąpień pojedynczych wystąpień.

## <a name="update-signalr-code"></a>Aktualizowanie kodu SignalR

`System.Text.Json` jest teraz domyślnie protokół Centrum używany przez klienta i serwera.

W `Startup.ConfigureServices`, wywołaj `AddJsonProtocol` Aby ustawić opcje serializatora.

**Serwer:**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Klient:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Przełącz się do pakietu Newtonsoft.Json

Jeśli używasz funkcji `Newtonsoft.Json` , nie są obsługiwane w `System.Text.Json`, możesz przełączyć się ponownie do `Newtonsoft.Json`:

1. Zainstaluj [Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) pakietu NuGet.
1. Na komputerze klienckim, połączyć w łańcuch `AddNewtonsoftJsonProtocol` wywołanie metody do `HubConnectionBuilder` wystąpienie:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Na serwerze, należy utworzyć łańcuch `AddNewtonsoftJsonProtocol` wywołanie metody do `AddSignalR` metody wywołania w `Startup.ConfigureServices`:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Zgódź się na kompilacja środowiska uruchomieniowego

3.0 kompilacja środowiska uruchomieniowego jest scenariusz zgłoszenie zgody na uczestnictwo. Aby włączyć kompilacja środowiska uruchomieniowego, zobacz <xref:mvc/views/view-compilation#runtime-compilation>.
