---
title: Wyprowadzanie podkluczy i uwierzytelnione szyfrowanie w programie ASP.NET Core
author: rick-anderson
description: Dowiedz się, szczegóły implementacji ochrony danych programu ASP.NET Core podklucza pochodnym i uwierzytelnione szyfrowanie.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: bbfde378755b09cd5b1217b8cf66249b9fa1d6ad
ms.sourcegitcommit: 8516b586541e6ba402e57228e356639b85dfb2b9
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/11/2019
ms.locfileid: "67814384"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="87e98-103">Wyprowadzanie podkluczy i uwierzytelnione szyfrowanie w programie ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="87e98-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="87e98-104">Większość klawiszy pierścienia klucz będzie zawierać jakąś postać entropii i będą zawierać informacje algorytmicznego, podając w "trybie CBC szyfrowanie i weryfikacja HMAC" lub "usługi GCM szyfrowanie i sprawdzanie poprawności".</span><span class="sxs-lookup"><span data-stu-id="87e98-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="87e98-105">W takich przypadkach nazywamy osadzone entropii materiał klucza głównego (lub KM) dla tego klucza, a następnie wykonamy funkcji wyprowadzania klucza do tworzenia kluczy, które będą używane dla operacje kryptograficzne.</span><span class="sxs-lookup"><span data-stu-id="87e98-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="87e98-106">Klucze są abstrakcyjne, a implementacja niestandardowa mogą nie zachowywać się zgodnie z poniższymi instrukcjami.</span><span class="sxs-lookup"><span data-stu-id="87e98-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="87e98-107">Jeśli klucz zapewnia własną implementację `IAuthenticatedEncryptor` zamiast przy użyciu jednego z naszych wbudowanych fabryki, mechanizm opisane w tej sekcji nie ma już zastosowania.</span><span class="sxs-lookup"><span data-stu-id="87e98-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="87e98-108">Dodatkowe dane uwierzytelnionego i wyprowadzanie podkluczy</span><span class="sxs-lookup"><span data-stu-id="87e98-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="87e98-109">`IAuthenticatedEncryptor` Interfejsu służy jako interfejs podstawowe dla wszystkich operacji szyfrowania uwierzytelniony.</span><span class="sxs-lookup"><span data-stu-id="87e98-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="87e98-110">Jego `Encrypt` metoda przyjmuje dwa buforów: zwykłego tekstu i additionalAuthenticatedData (AAD).</span><span class="sxs-lookup"><span data-stu-id="87e98-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="87e98-111">Przepływ zawartości zwykłego tekstu bez zmian wywołanie `IDataProtector.Protect`, ale usługi AAD jest generowany przez system i składa się z trzech składników:</span><span class="sxs-lookup"><span data-stu-id="87e98-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="87e98-112">Nagłówek magic 32-bitowych 09 F0 F0 C9, który identyfikuje tę wersję system ochrony danych.</span><span class="sxs-lookup"><span data-stu-id="87e98-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="87e98-113">Identyfikator klucza 128-bitowego.</span><span class="sxs-lookup"><span data-stu-id="87e98-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="87e98-114">Ciąg znaków o zmiennej długości utworzone z łańcucha celem utworzenia `IDataProtector` , jest wykonanie tej operacji.</span><span class="sxs-lookup"><span data-stu-id="87e98-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="87e98-115">Usługi AAD jest unikatowy dla krotki wszystkie trzy składniki, możemy użyć go do wyprowadzenia nowych kluczy z KM zamiast KM sama we wszystkich naszych operacji kryptograficznych.</span><span class="sxs-lookup"><span data-stu-id="87e98-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="87e98-116">Dla każdego wywołania `IAuthenticatedEncryptor.Encrypt`, odbywa się następujący proces wyprowadzania klucza:</span><span class="sxs-lookup"><span data-stu-id="87e98-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

<span data-ttu-id="87e98-117">(K_E, K_H) = SP800_108_CTR_HMACSHA512 (contextHeader K_M, usługi AAD, || keyModifier)</span><span class="sxs-lookup"><span data-stu-id="87e98-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span></span>

<span data-ttu-id="87e98-118">W tym miejscu Zadzwonimy pod numer telefonu KDF SP800 108 NIST w trybie licznika (zobacz [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), s. 5.1) z następującymi parametrami:</span><span class="sxs-lookup"><span data-stu-id="87e98-118">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="87e98-119">Klucz klucza pochodnego (KDK) = K_M</span><span class="sxs-lookup"><span data-stu-id="87e98-119">Key derivation key (KDK) = K_M</span></span>

* <span data-ttu-id="87e98-120">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="87e98-120">PRF = HMACSHA512</span></span>

* <span data-ttu-id="87e98-121">Etykieta = additionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="87e98-121">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="87e98-122">kontekst = contextHeader || keyModifier</span><span class="sxs-lookup"><span data-stu-id="87e98-122">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="87e98-123">Nagłówek kontekstu jest o zmiennej długości i zasadniczo pełni rolę algorytmów, dla których firma Microsoft jest wyprowadzanie K_E i K_H odcisku palca.</span><span class="sxs-lookup"><span data-stu-id="87e98-123">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving K_E and K_H.</span></span> <span data-ttu-id="87e98-124">Modyfikator klucza jest ciągiem 128-bitowego losowo generowany dla każdego wywołania `Encrypt` i służy do zapewnienia przeciążenia prawdopodobieństwo, że KE i KH unikatowy dla tej operacji szyfrowania określonego uwierzytelniania, nawet jeśli wszystkie inne dane wejściowe do KDF jest stałe.</span><span class="sxs-lookup"><span data-stu-id="87e98-124">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="87e98-125">W trybie CBC szyfrowania + HMAC operacji sprawdzania poprawności | K_E | to długość klucza szyfrowania symetrycznego bloku, a | K_H | jest to rozmiar szyfrowanego procedury HMAC.</span><span class="sxs-lookup"><span data-stu-id="87e98-125">For CBC-mode encryption + HMAC validation operations, | K_E | is the length of the symmetric block cipher key, and | K_H | is the digest size of the HMAC routine.</span></span> <span data-ttu-id="87e98-126">Szyfrowanie usługi GCM i operacje sprawdzania poprawności | K_H | = 0.</span><span class="sxs-lookup"><span data-stu-id="87e98-126">For GCM encryption + validation operations, | K_H | = 0.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="87e98-127">Trybie CBC szyfrowanie i weryfikacja HMAC</span><span class="sxs-lookup"><span data-stu-id="87e98-127">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="87e98-128">Po wygenerowaniu K_E za pośrednictwem mechanizmu powyższych możemy wektor inicjowania losowe generowanie, a następnie uruchom algorytmu szyfrowania symetrycznego bloku do szyfrowania w formie zwykłego tekstu.</span><span class="sxs-lookup"><span data-stu-id="87e98-128">Once K_E is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="87e98-129">Wektor inicjowania i tekstu szyfrowanego są następnie uruchamiane za pomocą procedury HMAC zainicjowane z użyciem klucza K_H do produkcji na komputerze MAC.</span><span class="sxs-lookup"><span data-stu-id="87e98-129">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key K_H to produce the MAC.</span></span> <span data-ttu-id="87e98-130">Ten proces i wartość zwracana jest reprezentowane graficznie poniżej.</span><span class="sxs-lookup"><span data-stu-id="87e98-130">This process and the return value is represented graphically below.</span></span>

![Proces w trybie CBC i wróć](subkeyderivation/_static/cbcprocess.png)

<span data-ttu-id="87e98-132">*dane wyjściowe: = keyModifier || IV || E_cbc (dane K_E, iv) || HMAC (K_H, iv || E_cbc (dane K_E, iv))*</span><span class="sxs-lookup"><span data-stu-id="87e98-132">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span></span>

> [!NOTE]
> <span data-ttu-id="87e98-133">`IDataProtector.Protect` Wdrożenia będzie [dołączana magic nagłówek i identyfikator klucza](xref:security/data-protection/implementation/authenticated-encryption-details) danych wyjściowych przed zwróceniem do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="87e98-133">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="87e98-134">Ponieważ magic nagłówek i identyfikator klucza są niejawnie wchodzi w skład [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), a ponieważ modyfikator klucza jest podawany jako dane wejściowe KDF, oznacza to, że każdy jeden bajt końcowy ładunek zwracany jest uwierzytelniany przez komputerów MAC.</span><span class="sxs-lookup"><span data-stu-id="87e98-134">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="87e98-135">Tryb Galois liczników szyfrowanie i weryfikacja</span><span class="sxs-lookup"><span data-stu-id="87e98-135">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="87e98-136">Po wygenerowaniu K_E za pośrednictwem mechanizmu powyższych możemy Generowanie losowe jednorazowego 96-bitowym, a następnie uruchom algorytmu szyfrowania symetrycznego bloku szyfrowanie w postaci zwykłego tekstu i utworzyć tag uwierzytelniania 128-bitowego.</span><span class="sxs-lookup"><span data-stu-id="87e98-136">Once K_E is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![Proces trybu GCM i wróć](subkeyderivation/_static/galoisprocess.png)

<span data-ttu-id="87e98-138">*dane wyjściowe: = keyModifier || Identyfikator jednorazowy || E_gcm (K_E, jednorazowy, dane) || authTag*</span><span class="sxs-lookup"><span data-stu-id="87e98-138">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span></span>

> [!NOTE]
> <span data-ttu-id="87e98-139">Mimo że GCM natywnie obsługuje pojęcia usługi AAD, firma Microsoft jest nadal wprowadzając AAD tylko z oryginalnego KDF, aby przekazać pusty ciąg do usługi GCM dla jej parametru usługi AAD.</span><span class="sxs-lookup"><span data-stu-id="87e98-139">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="87e98-140">Przyczyna to składa się z dwóch etapów.</span><span class="sxs-lookup"><span data-stu-id="87e98-140">The reason for this is two-fold.</span></span> <span data-ttu-id="87e98-141">Po pierwsze, [do obsługi elastyczność](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) nigdy nie chcemy użyć K_M bezpośrednio jako klucza szyfrowania.</span><span class="sxs-lookup"><span data-stu-id="87e98-141">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use K_M directly as the encryption key.</span></span> <span data-ttu-id="87e98-142">Ponadto usługa GCM nakłada unikatowości bardzo ścisłe wymagania dotyczące jego danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="87e98-142">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="87e98-143">Prawdopodobieństwo, że procedura szyfrowania usługi GCM jest nigdy nie są wywoływane na dwóch lub więcej różnych zestawów danych wejściowych o takiej samej (klucz, jednorazowy) pary nie może przekraczać 2 ^ 32.</span><span class="sxs-lookup"><span data-stu-id="87e98-143">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="87e98-144">Jeśli firma Microsoft rozwiąże K_E nie można wykonać więcej niż 2 ^ 32 operacji szyfrowania przed możemy uruchomić afoul o 2 ^ ograniczyć -32.</span><span class="sxs-lookup"><span data-stu-id="87e98-144">If we fix K_E we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="87e98-145">To może wydawać się bardzo dużej liczby operacji, ale serwer sieci web o dużym natężeniu ruchu mogą być używane za pośrednictwem 4 miliardów żądań w kilku dni, również w ramach normalnych okres istnienia dla tych kluczy.</span><span class="sxs-lookup"><span data-stu-id="87e98-145">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="87e98-146">Aby pozostają zgodne 2 ^ limit prawdopodobieństwo-32 Kontynuujemy przy użyciu 128-bitowego klucza modyfikator i jednorazowego 96-bitowym, która znacząco rozszerza liczbę operacji można używać dla dowolnego danego K_M.</span><span class="sxs-lookup"><span data-stu-id="87e98-146">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given K_M.</span></span> <span data-ttu-id="87e98-147">Dla uproszczenia projektu udostępniamy ścieżka kodu KDF między operacjami CBC i GCM, a ponieważ usługi AAD już jest uważana za KDF nie ma potrzeby ją przesłać do procedury usługi GCM.</span><span class="sxs-lookup"><span data-stu-id="87e98-147">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
